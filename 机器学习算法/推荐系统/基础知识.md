

CTR即点击通过率，指网络广告的点击到达率，即该广告的实际点击次数除以广告的展现量。

##### 推荐系统与搜索引擎

推荐系统就是系统根据用户的属性，用户在系统里过去的行为，以及当前上下文环境 ( 如网络、手机设备、时间等 )，从而给用户推荐用户可能感兴趣的物品，从这个过程来看，推荐系统就是一个给 user 匹配感兴趣的 item 的过程。

![推荐引擎架构](../../picture/1/264.png)

搜索引擎需要 match 的是 query 和相关的 doc；推荐系统需要 match 的是 user和相关的 item。

![搜索引擎架构](../../picture/1/263.png)

###### 搜索与推荐不同

1. 意图不同：搜索是用户带着明确的目的，通过给系统输入 query 来主动触发的，搜索过程用户带着明确的搜索意图。而推荐是系统被动触发，用户是以一种闲逛的姿态过来的，系统是带着一种 "猜" 的状态给用户推送物品。
2. 时效不同：搜索需要尽快满足用户此次请求 query，推荐更希望能增加用户的时长和留存从而提升整体 LTV 。
3. 相关性要求不同：搜索有严格的 query 限制，搜索结果需要保证相关性，搜索结果量化评估标准也相对容易。给定一个 query，系统给出不同结果，在上线前就可以通过相关性对结果进行判定相关性好坏。而推荐没有明确的相关性要求。推荐很难在离线阶段从相关性角度结果评定是否好坏，只能从线上效果看用户是否买单做评估。
4. 实体不同：搜索中的两大实体是 query 和 doc，本质上都是文本信息。这就是上文说到的为什么搜索可以通过 query 和 doc 的文本相关性判断是否相关。Query 和 doc 的匹配过程就是在语法层面理解 query 和 doc 之间 gap 的过程。推荐中的两大实体是 user 和 item，两者的表征体系可能完全没有重叠。这就决定了推荐中，user 和 item 的匹配是无法从表面的特征解决两者 gap 的。
5. 个性化要求不同：搜索和推荐天然对个性化需求不同。搜索有用户的主动 query，本质上这个 query 已经在告诉系统这个 "用户" 是谁了，query 本身代表的就是一类用户，而推荐没有用户主动的 query 输入，如果没有用户画像属性和过去行为的刻画，系统基本上就等于瞎猜。

###### 搜索与推荐相同

1. 本质都是match过程：如果把 user 比作 query，把 item 比作 doc，那么推荐和搜索在这个层面又是相同的，都是针对一个 query ( 一个 user )，从海量的候选物品库中，根据 query 和 doc 的相关性 ( user 过去的历史、画像等和 item 的匹配程度 )，去推荐匹配的 doc ( item )。
2. 目标相同：搜索和推荐的目标都是针对一次 context ( 或者有明确意图，或者没有 )，从候选池选出尽可能满足需求的物品。两者区别只是挑选过程使用的信息特征不同。
3. 语义鸿沟都是两者醉倒的挑战：在搜索里表现是 query 和 doc 的语义理解，推荐里则是 user 和 item 的理解。

##### 推荐系统目标

推荐引擎的期望目标，包括以下四点：

相关性：推荐的东西只有和用户相关才会有意义。用户更有可能购买或消费他们感兴趣的商品。

新颖性：除了相关性之外，新颖性也是另一个重要因素。如果推荐的项目是用户以前没有看过或消费过的，那么推荐也将更有意义。

偶然性：有时推荐一些出乎意料的项目也能促进销售。然而，偶然性与新颖性不同。

多样性：此外，增加推荐的多样性也同样重要。简单地推荐与此类似的商品并没有多大用处。

##### 推荐系统步骤

推荐系统主要用于解决以下两个问题：

预测：用于预测用户-项目组合的评分值。在这种情况下，我们以用户提供的评分作为训练数据。其目的是利用这些数据对用户没有交互的商品预测其评分。

排序：没有必要为了进行推荐而预测特定商品的用户评分。在线零售商或电子商务公司并不太关心用户的预测。相反，他们更感兴趣的是列出一个有限的清单，能给特定的人群列出最好的东西来呈现给他们。

推荐系统一般分为两个阶段，即召回阶段和排序阶段。召回阶段主要是从全量的商品库中得到用户可能感兴趣的一小部分候选集，排序阶段则是将召回阶段得到的候选集进行精准排序，推荐给用户。

![](../../picture/1/218.png)

推荐系统，如果粗分的化，经常讲的有两个阶段。首先是召回，主要根据用户部分特征，从海量的物品库里，快速找回一小部分用户潜在感兴趣的物品，然后交给排序环节，排序环节可以融入较多特征，使用复杂模型，来精准地做个性化推荐。召回强调快，排序强调准。

![](../../picture/1/310.png)

如果我们更细致地看实用的推荐系统，一般会有四个环节，四个环节分别是：召回、粗排、精排和重排。召回目的如上所述；有时候因为每个用户召回环节返回的物品数量还是太多，怕排序环节速度跟不上，所以可以在召回和精排之间加入一个粗排环节，通过少量用户和物品特征，简单模型，来对召回的结果进行个粗略的排序，在保证一定精准的前提下，进一步减少往后传送的物品数量，粗排往往是可选的，可用可不同，跟场景有关。之后，是精排环节，使用你能想到的任何特征，可以上你能承受速度极限的复杂模型，尽量精准地对物品进行个性化排序。排序完成后，传给重排环节，传统地看，这里往往会上各种技术及业务策略，比如去已读、去重、打散、多样性保证、固定类型物品插入等等，主要是技术产品策略主导或者为了改进用户体验的。

##### 推荐模型更新

增量更新仅将新加入的样本喂入模型进行增量学习。从技术上来说，深度学习模型往往采用随机梯度下降以及其变种进行学习，模型对增量样本的学习相当于在原有样本的基础上继续输入增量样本进行梯度下降。因此在深度学习模型的基础上，由全量更新改为增量更新的难度并不大。由于仅利用增量样本进行学习，因此模型在多个epoch之后也是收敛到新样本的最优点，而很难收敛到原所有样本+增量样本的全局最优点。

因此在实际的推荐系统中，往往采用增量更新与全局更新相结合的方式，在进行几轮增量更新后，在业务量较小的时间窗口进行全局更新，纠正模型在增量更新过程后中积累的误差。

提高模型实时性的另外一个改进方向是进行模型的局部更新，大致的思路是降低训练效率低的部分的更新频率，提高训练效率高的部分的更新频率。

对于推荐系统来说，就是先计算好每个用户的推荐，将推荐结果存储下来，通过预先将推荐结果存下来，可以更快的为用户提供推荐服务,提升用户体验。由于推荐系统会为每个用户生成推荐结果,并且每天都会(基本全量)更新用户的推荐结果，一般采用NoSql数据库来存储，并且要求数据库可拓展，高可用，支持大规模并发读写。

### 推荐系统架构

![](../../picture/1/344.png)

数据流实线为在线流程，虚线为离线流程。一般在线流程指用户实时访问系统用于计算及使用的服务，离线流程指跟用户请求无直接关系可对数据单独统计计算的过程。

| 组成元素 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 物料数据 | 首先要有很多被推荐的物料数据，每个物料具有唯一id，还应有其自身的各类基础信息，例如：类型，类别，标签，地域等 |
| 用户数据 | 通过埋点记录用户各类行为，通过日志收集系统计算处理，将有效的用户行为数据结构化并落到存储空间中 |
| 用户画像 | 通过对用户数据进行分析，计算出所需维度的用户画像，便于后续使用 |
| 实时计算 | 实时收集日志并解析物料与用户的实时统计信息，用于后续算法特征处理或在线规则处理。 |
| 算法模块 | 通过物料数据和用户数据建立推荐算法模型                       |
| 推荐引擎 | 如果实时性不强，那么在离线按小时或天的频次直接计算各个用户可能的偏好物料，可以通过用户画像匹配物料，也可以通过模型进行预测排序 |
| 数据报表 | 用来展示推荐系统整体效果，包括AB实验效果，分标签、召回等维度效果等，用于后续迭代优化时提供数据支撑。 |

#### 数据管理

物料数据需要一个统一模块管理生成的所有物料，结构化后同步到资源池中，供后续正排及倒排的创建。用户日志通过`kafka`收集后，基于不同的计算方式消费日志数据，定时落入数据仓库或实时计算用户或物料数据，数据仓库中存储原始日志表和基于其生成的各种中间表，用来计算用户画像或统计物料信息。

![](../../picture/1/345.png)

###### 物料数据

存储

倒排一般根据物料某一字段或某些字段组合反查物料id，

#### 算法管理

主要是通过离线或在线拿到特征及样本数据训练模型，将训练好的模型同步给召回或排序的预测服务，推荐引擎实时调用预测结果供召回及排序使用。

#### 推荐引擎管理

推荐引擎能够实时给用户提供推荐服务，用来解析用户请求，将物料数据与画像数据打通，匹配符合用户兴趣的物料，同时调用算法召回，控制整体候选集多样性。通过排序预测服务为候选集打分排序给出用户可能感兴趣的结果，并根据业务和体验规则对推荐结果进行重排序，呈现给用户最终结果。同时推荐引擎还承担着线上AB实验精准分桶的功能，保证实验流量的科学分配，提升实验效果的置信度。

推荐引擎核心功能的主要有用户请求解析、实验分桶染色、召回、排序、重排等模块。

##### 召回

召回的方式主要分为基于兴趣内容类，协同过滤类及算法类，最终候选集的呈现可以是这些召回的组合。

##### 排序

针对召回出的候选集进行排序得到用户最可能感兴趣的内容，需要打分的物料只有几百上千条，因此可以使用更多维度的特征和复杂模型进行线上预测，这块流程同算法召回类似，统一调用排序预测服务即可

##### 重排序



#### 推荐系统冷启动

推荐系统冷启动问题指的就是对于新注册的用户或者新入库的标的物, 该怎么给新用户推荐标的物让用户满意，怎么将新标的物分发出去，推荐给喜欢它的用户。推荐系统冷启动主要分为标的物冷启动、用户冷启动、系统冷启动三大类。

难点： 我们一般对新用户知之甚少，从而很难为用户推荐他喜欢的标的物；对于新的标的物，我们也不知道什么用户会喜欢它；对于新开发的产品，由于是从零开始发展用户，冷启动问题就更加凸显，这时每个用户都是冷启动用户

##### 冷启动的方法和策略

###### 提供非个性化的推荐

 利用先验数据做推荐，可以利用新热标的物作为推荐。推荐新的东西肯定能抓住用户的眼球，推荐热门标的物, 由于这些标的物是热点，同时人是有从众效应的，热门推荐也一般用来作为新推荐算法的AB测试的基准对照组。还可以推荐常用的标的物及生活必需品。对于特殊行业，可以根据该行业的经验给出相应的推荐策略。

给用户提供多样化的选择，最好是从一些热门的类中挑选一些推荐给用户。太冷门的类用户不喜欢的概率较大，避免推荐的热门物品来自同一类，使得推荐结果单一。

###### 利用用户注册时提供的信息

 利用人口统计学数据，根据用户注册是填写的基本信息构建用户画像，通过用户画像标签关联物品从而为用户做推荐。

利用社交关系，用户在注册是导入社交关系，将好友喜欢的物品推荐的给用户。利用社交信息来做冷启动，特别是在有社交属性的产品中，这是很常见的一种方法

利用用户填写的兴趣点，用户注册时填写兴趣点，通过这些兴趣点为用户推荐感兴趣的物品。

###### 基于内容做推荐

基于内容的推荐算法，基于内容的推荐算法只要用户有少量行为就可以给用户推荐，通过用户浏览过的少量商品的相关标签，将同一类的物品推荐给用户。

###### 利用标的物的`metadata`信息做推荐

利用标的物跟用户行为的相似性，可以通过提取新入库的标的物的特征，通过计算标的物特征跟用户行为特征的相似性，从而将标的物推荐给与它最相似的用户。

 利用标的物跟标的物的相似性，根据这些属性找到与该标的物最相似的标的物，这些相似的标的物被哪些用户“消费”过，可以将该标的物推荐给这些消费过的用户。

###### 采用快速试探策略

这类策略一般可用于新闻短视频类应用中, 先随机或者按照非个性化推荐的策略给用户推荐，基于用户的点击反馈快速发现用户的兴趣点，从而在短时间内挖掘出用户的兴趣。

###### 采用兴趣迁移策略

当一个公司有一个成熟的`APP`时，准备拓展新的业务，开发新的`APP`，这时可以将用户在老`APP`上的特征迁移到新`APP`中, 从而做出推荐。兴趣迁移策略借鉴了迁移学习的思路，在基于主产品拓展新产品形态的情况下，特别适合新产品做冷启动。

###### 采用基于关系传递的策略

当产品在拓展标的物品类的过程中，先计算原有的物品类A与用户的相似度，然后计算新类型物品B与A的相似度，将B推荐给跟A相似度高的客户。B与A有相似关系，A与喜欢它的用户有相似关系，最终得到B与用户有相似关系。

| 冷启动形式   | 方案                                                         |
| ------------ | ------------------------------------------------------------ |
| 用户冷启动   | 提供非个性化的推荐、利用用户注册时提供的信息、基于内容做推荐、采用快速试探策略、采用兴趣迁移策略 |
| 标的物冷启动 | 利用标的物的`metadata`信息做推荐、采用快速试探策略、采用基于关系传递的策略 |
| 系统冷启动   | 利用用户注册时提供的信息、基于内容做推荐、采用兴趣迁移策略   |

范式1：完全个性化范式：为每个用户提供个性化的内容，每个用户推荐结果都不同；

范式2：群组个性化范式：首先将用户分组(根据用户的兴趣，将兴趣相似的归为一组)，每组用户提供一个个性化的推荐列表，同一组的用户推荐列表一样，不同组的用户推荐列表不一样；

范式3：非个性化范式：为所有用户提供完全一样的推荐；

范式4：标的物关联标的物范式：为每个标的物关联一组标的物，作为用户在访问标的物详情页时的推荐，每个用户都是相同的标的物；

范式5：笛卡尔积范式：每个用户跟每个标的物的组合产生的推荐都不相同，不同用户在同一个视频的详情页看到的推荐结果都不一样；