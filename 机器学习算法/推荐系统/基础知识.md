

##### 推荐系统与搜索引擎

推荐系统就是系统根据用户的属性，用户在系统里过去的行为，以及当前上下文环境 ( 如网络、手机设备、时间等 )，从而给用户推荐用户可能感兴趣的物品，从这个过程来看，推荐系统就是一个给 user 匹配感兴趣的 item 的过程。

![推荐引擎架构](../../picture/1/264.png)

搜索引擎需要 match 的是 query 和相关的 doc；推荐系统需要 match 的是 user和相关的 item。

![搜索引擎架构](../../picture/1/263.png)

###### 搜索与推荐不同

1. 意图不同：搜索是用户带着明确的目的，通过给系统输入 query 来主动触发的，搜索过程用户带着明确的搜索意图。而推荐是系统被动触发，用户是以一种闲逛的姿态过来的，系统是带着一种 "猜" 的状态给用户推送物品。
2. 时效不同：搜索需要尽快满足用户此次请求 query，推荐更希望能增加用户的时长和留存从而提升整体 LTV 。
3. 相关性要求不同：搜索有严格的 query 限制，搜索结果需要保证相关性，搜索结果量化评估标准也相对容易。给定一个 query，系统给出不同结果，在上线前就可以通过相关性对结果进行判定相关性好坏。而推荐没有明确的相关性要求。推荐很难在离线阶段从相关性角度结果评定是否好坏，只能从线上效果看用户是否买单做评估。
4. 实体不同：搜索中的两大实体是 query 和 doc，本质上都是文本信息。这就是上文说到的为什么搜索可以通过 query 和 doc 的文本相关性判断是否相关。Query 和 doc 的匹配过程就是在语法层面理解 query 和 doc 之间 gap 的过程。推荐中的两大实体是 user 和 item，两者的表征体系可能完全没有重叠。这就决定了推荐中，user 和 item 的匹配是无法从表面的特征解决两者 gap 的。
5. 个性化要求不同：搜索和推荐天然对个性化需求不同。搜索有用户的主动 query，本质上这个 query 已经在告诉系统这个 "用户" 是谁了，query 本身代表的就是一类用户，而推荐没有用户主动的 query 输入，如果没有用户画像属性和过去行为的刻画，系统基本上就等于瞎猜。

###### 搜索与推荐相同

1. 本质都是match过程：如果把 user 比作 query，把 item 比作 doc，那么推荐和搜索在这个层面又是相同的，都是针对一个 query ( 一个 user )，从海量的候选物品库中，根据 query 和 doc 的相关性 ( user 过去的历史、画像等和 item 的匹配程度 )，去推荐匹配的 doc ( item )。
2. 目标相同：搜索和推荐的目标都是针对一次 context ( 或者有明确意图，或者没有 )，从候选池选出尽可能满足需求的物品。两者区别只是挑选过程使用的信息特征不同。
3. 语义鸿沟都是两者醉倒的挑战：在搜索里表现是 query 和 doc 的语义理解，推荐里则是 user 和 item 的理解。

##### 推荐系统目标

推荐引擎的期望目标，包括以下四点：

相关性：推荐的东西只有和用户相关才会有意义。用户更有可能购买或消费他们感兴趣的商品。

新颖性：除了相关性之外，新颖性也是另一个重要因素。如果推荐的项目是用户以前没有看过或消费过的，那么推荐也将更有意义。

偶然性：有时推荐一些出乎意料的项目也能促进销售。然而，偶然性与新颖性不同。

多样性：此外，增加推荐的多样性也同样重要。简单地推荐与此类似的商品并没有多大用处。

##### 推荐系统步骤

推荐系统主要用于解决以下两个问题：

预测：用于预测用户-项目组合的评分值。在这种情况下，我们以用户提供的评分作为训练数据。其目的是利用这些数据对用户没有交互的商品预测其评分。

排序：没有必要为了进行推荐而预测特定商品的用户评分。在线零售商或电子商务公司并不太关心用户的预测。相反，他们更感兴趣的是列出一个有限的清单，能给特定的人群列出最好的东西来呈现给他们。

推荐系统一般分为两个阶段，即召回阶段和排序阶段。召回阶段主要是从全量的商品库中得到用户可能感兴趣的一小部分候选集，排序阶段则是将召回阶段得到的候选集进行精准排序，推荐给用户。

![](../../picture/1/218.png)

推荐系统，如果粗分的化，经常讲的有两个阶段。首先是召回，主要根据用户部分特征，从海量的物品库里，快速找回一小部分用户潜在感兴趣的物品，然后交给排序环节，排序环节可以融入较多特征，使用复杂模型，来精准地做个性化推荐。召回强调快，排序强调准。

![](../../picture/1/310.png)

如果我们更细致地看实用的推荐系统，一般会有四个环节，四个环节分别是：召回、粗排、精排和重排。召回目的如上所述；有时候因为每个用户召回环节返回的物品数量还是太多，怕排序环节速度跟不上，所以可以在召回和精排之间加入一个粗排环节，通过少量用户和物品特征，简单模型，来对召回的结果进行个粗略的排序，在保证一定精准的前提下，进一步减少往后传送的物品数量，粗排往往是可选的，可用可不同，跟场景有关。之后，是精排环节，使用你能想到的任何特征，可以上你能承受速度极限的复杂模型，尽量精准地对物品进行个性化排序。排序完成后，传给重排环节，传统地看，这里往往会上各种技术及业务策略，比如去已读、去重、打散、多样性保证、固定类型物品插入等等，主要是技术产品策略主导或者为了改进用户体验的。

##### 推荐模型更新

增量更新仅将新加入的样本喂入模型进行增量学习。从技术上来说，深度学习模型往往采用随机梯度下降以及其变种进行学习，模型对增量样本的学习相当于在原有样本的基础上继续输入增量样本进行梯度下降。因此在深度学习模型的基础上，由全量更新改为增量更新的难度并不大。由于仅利用增量样本进行学习，因此模型在多个epoch之后也是收敛到新样本的最优点，而很难收敛到原所有样本+增量样本的全局最优点。

因此在实际的推荐系统中，往往采用增量更新与全局更新相结合的方式，在进行几轮增量更新后，在业务量较小的时间窗口进行全局更新，纠正模型在增量更新过程后中积累的误差。

提高模型实时性的另外一个改进方向是进行模型的局部更新，大致的思路是降低训练效率低的部分的更新频率，提高训练效率高的部分的更新频率。

对于推荐系统来说，就是先计算好每个用户的推荐，将推荐结果存储下来，通过预先将推荐结果存下来，可以更快的为用户提供推荐服务,提升用户体验。由于推荐系统会为每个用户生成推荐结果,并且每天都会(基本全量)更新用户的推荐结果，一般采用NoSql数据库来存储，并且要求数据库可拓展，高可用，支持大规模并发读写。

##### 推荐系统冷启动

推荐系统冷启动问题指的就是对于新注册的用户或者新入库的标的物, 该怎么给新用户推荐标的物让用户满意，怎么将新标的物分发出去，推荐给喜欢它的用户。

提供非个性化的推荐(用户冷启动)

利用用户注册时提供的信息(用户冷启动、系统冷启动)

基于内容做推荐(用户冷启动、系统冷启动)

利用标的物的metadata信息做推荐(标的物冷启动)

采用快速试探策略(用户冷启动、标的物冷启动)    

采用兴趣迁移策略(用户冷启动、系统冷启动)    

采用基于关系传递的策略(标的物冷启动)

内容分析的结果主要有两类：一个是用户画像和物品画像的结构化内容库，另一个是分析过程中可能得到的模型，如主题模型、分类器模型、实体识别模型、嵌入模型等，这些模型主要用于实时推荐刚刚加入的新物品，通过对物品内容的实时分析，提取结构化内容，再用于用户画像匹配。
基于内容的推荐，最简单的算法就是计算相似性，可以把用户画像和物品画像表示成稀疏的向量，两者之间计算余弦相似度，根据相似度对推荐物品排序，也可以使用信息检索中的相关性计算

特征的实时性试图用更准确的特征描述一个人，从而让推荐系统给出更符合这个人的推荐结果。而模型的实时性则是希望更快的抓住全局层面的新的数据模式，发现新的趋势和相关性。特征的实时性会根据用户最近的行为更快的发现用户可能感兴趣的商品，但绝对不会发现用户相似人群最新的偏好，商品之间最新的相关性信息，新活动的趋势信息等。要发现这类全局性的数据变化，就需要更快地更新模型。而影响模型的实时性最重要的因素就是模型的训练方式。模型训练最常用的方式就是全量更新。模型会利用某时间段内的所有训练样本进行重新训练，再用训练好的新模型替代“过时”的模型。