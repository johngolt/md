##### KMP算法

 `KMP`算法的核心，它是主要利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。用成功匹配的位数减去匹配表中的匹配值就是下一次要移动的次数。

![](D:/MarkDown/picture/2/198.png)

![](D:/MarkDown/picture/2/199.png)

对于前缀就是除了最后个字符以外所有的顺序组合方式。比如 A、AB、ABC、ABCA、ABCAB。后缀正好相反，除了第一个字符外，其他所有的组合方式。比如BCABD、CABD、ABD、ABD、BD、D。对于每个匹配值是如何计算的，那就对子串的每个字符组合寻找出前缀和后缀，然后进行比较是否有相同的，相同的字符组合有几位，就是所谓的匹配值。

![](D:/MarkDown/picture/2/200.png)

###### Bloom Filter

在哈希表中存放的是元素本身，而 Bloom Filter 在内存中是一个足够大的位数组(Bit Array)，其最小的内存使用单位是Bit。元素在插入Bloom Filter时，使用哈希函数(Hash Function)计算其哈希值确定其在位数组中的位置索引，然后将位数组中的指定Bit从0置1即可(如该Bit已经被置1，则无需再次置1)。当使用Bloom Filter判定指定元素是否存在其中时，同样利用该Hash Function先计算哈希值，确定其在位数组的中位置索引，然后取出该位置的值， 若该Bit为0，则说明该元素不存在于其中；若该Bit为1，则说明该元素存在于其中。现已向一个Bloom Filter分别插入元素"Hello"、"World"为例，给出其插入过程的图解

![](D:/MarkDown/picture/2/265.png)

故判定一个元素是否存在于Bloom Filter，如果判定结果是不存在(False)，则一定不存在；但是如果判定结果是存在(True)，则实际情况其实是可能存在，而不是一定存在，即假阳性。 所以，实际应用中，在Bloom Filter 一般会使用多个Hash Function，以减小发生哈希冲突的概率。即，减小误判率 P(true)。插入一个元素时，分别计算其在各个Hash Function的哈希值，然后将各个哈希值对应的Bit的值置1；而判定元素是否存在于Bloom Filter时，则要求各个哈希值对应的Bit的值均为1才行

![](D:/MarkDown/picture/2/266.png)

Bloom Filter 中涉及到的一些参数指标：

- 欲插入Bloom Filter中的元素数目: n
- Bloom Filter误判率: P(true)
- BitArray数组的大小: m
- Hash Function的数目: k

欲插入Bloom Filter中的元素数目 n 是我们在实际应用中可以提前获取或预估的；Bloom Filter的误判率 P(true) 则是我们提前设定的可以接受的容错率。所以在设计Bloom Filter过程中，最关键的参数就是BitArray数组的大小 m 和 Hash Function的数目 k。$P(true) = (p_1^n)^k=[1-(1-\frac{1}{m})^{kn}]^k$。从上式可以看出，当BitArray数组的大小m增大 或 欲插入Bloom Filter中的元素数目n 减小时，均可以使得误判率P(true)下降

##### 算法技巧

巧用数组下标：数组的下标是一个隐含的很有用的数组，特别是在统计一些数字，或者判断一些整型数是否出现过的时候。

巧用取余：有时候我们在遍历数组的时候，会进行越界判断，如果下标差不多要越界了，我们就把它置为0重新遍历。

巧用双指针：比如“判断单链表是否有环”、“如何一次遍历就找到链表中间位置节点”、“单链表中倒数第 k 个节点”等问题。对于第一个问题，我们就可以设置一个慢指针和一个快指针来遍历这个链表。慢指针一次移动一个节点，而快指针一次移动两个节点，如果该链表没有环，则快指针会先遍历完这个表，如果有环，则快指针会在第二次遍历时和慢指针相遇。对于第二个问题，一样是设置一个快指针和慢指针。慢的一次移动一个节点，而快的两个。在遍历链表的时候，当快指针遍历完成时，慢指针刚好达到中点。对于第三个问题，设置两个指针，其中一个指针先移动k个节点。之后两个指针以相同速度移动。当那个先移动的指针遍历完成的时候，第二个指针正好处于倒数第k个节点。

巧用移位运算：有时候我们在进行除数或乘数运算的时候，我们就可以用移位的方法来运算了，这样会快很多。n / 2 等价于 n >> 1；n / 4 等价于 n >> 2；n / 8 等价于 n >> 3。

<<左移 运算规则：按二进制形式把所有的数字向左移动对应的位数，高位移出，低位的空位补零。\>>右移，运算规则：按二进制形式把所有的数字向右移动对应的位数，低位移出，高位的空位补符号位，即正数补0，负数补1

设置哨兵位：在链表的相关问题中，我们经常会设置一个头指针，而且这个头指针是不存任何有效数据的，只是为了操作方便，这个头指针我们就可以称之为哨兵位了。