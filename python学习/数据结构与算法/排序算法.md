##### 排序算法

| 排序算法 | 平均时间复杂度 | 最好情况        | 最坏情况        | 空间复杂度   | 排序方式  | 稳定性 |
| -------- | -------------- | --------------- | --------------- | ------------ | --------- | ------ |
| 冒泡排序 | $O(n^2)$       | $O(n)$          | $O(n^2 )$       | $O(1)$       | In-place  | 稳定   |
| 选择排序 | $O(n^2)$       | $O(n^2)$        | $O(n^2)$        | $O(1)$       | In-place  | 不稳定 |
| 插入排序 | $O(n^2)$       | $O(n)$          | $O(n^2)$        | $O(1)$       | In-place  | 稳定   |
| 希尔排序 | $O(n\log(n))$  | $O(n\log^2(n))$ | $O(n\log^2(n))$ | $O(1)$       | In-place  | 不稳定 |
| 归并排序 | $O(n\log(n))$  | $O(n\log(n))$   | $O(n\log(n))$   | $O(n)$       | Out-place | 稳定   |
| 快速排序 | $O(n\log(n))$  | $O(n\log(n))$   | $O(n^2)$        | $O(\log(n))$ | In-place  | 不稳定 |
| 堆排序   | $O(n\log(n))$  | $O(n\log(n))$   | $O(n\log(n))$   | $O(1)$       | In-place  | 不稳定 |
| 计数排序 | $O(n + k)$     | $O(n + k)$      | $O(n + k)$      | $O(k)$       | Out-place | 稳定   |
| 桶排序   | $O(n + k)$     | $O(n + k)$      | $O(n^2)$        | $O(n + k)$   | Out-place | 稳定   |
| 基数排序 | $O(n\times k)$ | $O(n\times k)$  | $O(n\times k)$  | $O(n + k)$   | Out-place | 稳定   |

 稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就叫做「稳定排序」。

###### 冒泡排序

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

![](D:/MarkDown/picture/2/28.png)

算法优化：当某次冒泡过程已经没有数据交换时，说明已经达到完全有序，不用再执行后续的冒泡操作。在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

###### 选择排序

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；重复第二步，直到所有元素均排序完毕。

###### 插入排序

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

![](D:/MarkDown/picture/2/29.png)

###### 希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的：插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 

![](D:/MarkDown/picture/2/63.png)

![](D:/MarkDown/picture/2/64.png)

###### 归并排序

归并排序是一种基于分治思想的排序，处理的时候可以采取递归的方式来处理子问题。我们把它切割成两部分。把左半部分和右半部分分别排序好。之后再用一个临时数组，把这两个有序的子数组汇总成一个有序的大数组。左半部分和右半部分的排序相当于一个原问题的一个子问题的，也是采取同样的方式，把左半部分分成两部分，然后....直到分割子数组只有一个元素或0个元素时，这时子数组就是有序的了(因为只有一个元素或0个，肯定是有序的啊)，就不用再分割了，直接返回就可以了。

申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；设定两个指针，最初位置分别为两个已经排序序列的起始位置；比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。

###### 快速排序

快速排序也是和归并排序差不多，基于分治的思想以及采取递归的方式来处理子问题。我们可以随便选一个元素，假如我们选数组的第一个元素吧，我们把这个元素称之为”主元“吧。然后将大于或等于主元的元素放在右边，把小于或等于主元的元素放在左边。通过这种规则的调整之后，左边的元素都小于或等于主元，右边的元素都大于或等于主元，很显然，此时主元所处的位置，是一个有序的位置,即主元已经处于排好序的位置了。主元把数组分成了两半部分。把一个大的数组通过主元分割成两小部分的这个操作，我们也称之为分割操作(partition)。接下来，我们通过递归的方式，对左右两部分采取同样的方式，每次选取一个主元元素，使他处于有序的位置。

![](D:/MarkDown/picture/2/30.png)

分割操作

然后用令变量$i = left + 1，j = right$。然后让$ i $和$ j $从数组的两边向中间扫描。

![](D:/MarkDown/picture/2/31.png)

$i $向右遍历的过程中，如果遇到大于或等于主元的元素时，则停止移动，$j$向左遍历的过程中，如果遇到小于或等于主元的元素则停止移动。当$i$和$j$都停止移动时，如果这时$i < j$，则交换$ i, j $所指向的元素。此时$ i < j$，交换8和3。然后继续向中间遍历，直到$i >= j$。此时$i >= j$，分割结束。最后在把主元与$ j $指向的元素交换(当然，与$i$指向的交换也行)。这个时候，$j$左边的元素一定小于或等于主元，而右边则大于或等于主元。到此，分割调整完毕

###### 堆排序

 堆排序是指利用堆这种数据结构所设计的一种排序算法。  堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。 

1. 创建一个堆 $H[0……n-1]$；
2. 把堆首（最大值）和堆尾互换；
3. 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；
4. 重复步骤 2，直到堆的尺寸为 1。

###### 桶排序

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：在额外空间充足的情况下，尽量增大桶的数量；使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。

###### 基数排序

基数排序，是一种基数“桶”的排序，他的排序思路是这样的：先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小，排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是采用“桶”来排序的，基本原理就是把具有相同个（十、百等）位数的数放进同一个桶里。

![](D:/MarkDown/picture/2/32.png)

![](D:/MarkDown/picture/2/33.png)

基数的时间复杂度为O(n)，不过他是忽略了常数项，即实际排序时间为kn(其中k是常数项)，然而在实际排序的过程中，这个常数项k其实是很大的，这会很大程度影响实际的排序时间，而像快速排序虽然是$nlogn$，但它前面的常数项是相对比较小的，影响也相对比较小。

不采用从最高位到低位进行分桶的原因：最高位十位数排序显然，不在桶一个桶里的数，他们的大小顺序已经是已知的了，也就是说，**右边桶的数一定比左边桶的数大**，所有在接下来的个位数排序里，我们只需要进行“各部分”单独排序就可以了，每一小部分都类似于原问题的一个子问题，做的时候可以采用递归的形式来处理。这种方法确实可以减少比较的次数，不过请大家注意，在每个小部分的排序中，我们也是需要10个桶来将他们进行排序，最后导致的结果就是，**每个不同值的元素都会占据一个“桶”**，如果你有1000个元素，并且1000个元素都是不同值的话，那么从最高位排序到最低位，需要1000个桶。

###### 计数排序

假定20个随机整数的值如下：9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9 ，7，9

让我们遍历这个无序的随机数列，每一个整数按照其值对号入座，对应数组下标的元素进行加1操作。比如第一个整数是9，那么数组下标为9的元素加1：

![](D:/MarkDown/picture/2/16.png)

第二个整数是3，那么数组下标为3的元素加1

![](D:/MarkDown/picture/2/17.png)

继续遍历数列并修改数组，最终，数列遍历完毕时，数组的状态如下

![](D:/MarkDown/picture/2/18.png)

数组每一个下标位置的值，代表了数列中对应整数出现的次数。有了这个“统计结果”，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次。

对于其他属于某个区间的序列，不再以（输入数列的最大值+1）作为统计数组的长度，而是以（数列最大值和最小值的差+1）作为统计数组的长度。同时，数列的最小值作为一个偏移量，用于统计数组的对号入座。

统计数组从第二个元素开始，每一个元素都加上前面所有元素之和。这样相加的目的，是让统计数组存储的元素值，等于相应整数的最终排序位置。比如下标是9的元素值为5，代表原始数列的整数9，最终的排序是在第5位。接下来，我们创建输出数组$sortedArray$，长度和输入数列一致。然后从后向前遍历输入数列：第一步，我们遍历成绩表最后一行的小绿：小绿是95分，我们找到$countArray$下标是5的元素，值是4，代表小绿的成绩排名位置在第4位。同时，我们给$countArray$下标是5的元素值减1，从4变成3,，代表着下次再遇到95分的成绩时，最终排名是第3。

![](D:/MarkDown/picture/2/20.png)

第二步，我们遍历成绩表倒数第二行的小白：小白是94分，我们找到$countArray$下标是4的元素，值是2，代表小白的成绩排名位置在第2位。同时，我们给$countArray$下标是4的元素值减1，从2变成1,，代表着下次再遇到94分的成绩时，最终排名是第1。第三步，我们遍历成绩表倒数第三行的小红：小红是95分，我们找到$countArray$下标是5的元素，值是3，代表小红的成绩排名位置在第3位。同时，我们给$countArray$下标是5的元素值减1，从3变成2,，代表着下次再遇到95分的成绩时（实际上已经遇不到了），最终排名是第2。这样一来，同样是95分的小红和小绿就能够清楚地排出顺序了，也正因此，优化版本的计数排序属于**稳定排序**。

###### 外部排序

这种方法适合要排序的数据太多，以至于内存一次性装载不下。只能通过把数据分几次的方式来排序，我们也把这种方法称之为**外部排序**。

12个无序的数据：70，81，2，86，3，24，8，87，17，46，30，64

从12数据读取3个数据构建最小堆，且选出目标数

![](D:/MarkDown/picture/2/21.png)

读入下一个数86

![](D:/MarkDown/picture/2/22.png)

读入下一个数3，比70小，暂放一边，不加入堆结构中

![](D:/MarkDown/picture/2/23.png)

读入下一个数据24，比81小，不加入堆结构

![](D:/MarkDown/picture/2/24.png)

读入下一个数据8，比86小，不加入堆结构。此时$p_1$已经完成了，把那些刚才暂放一边的数重新构成一个堆，继续$p_2$的存放。

![](D:/MarkDown/picture/2/25.png)

以此类推...最后生成的$p_2$如下：

![](D:/MarkDown/picture/2/27.png)

最后对$p_1$和$p_2$进行排序，采用的排序方法如下所示。

![](D:/MarkDown/picture/2/26.png)

##### 