* * 左侧变量名序列有两个星号，如`*a,*b="abcd"`
  * 左侧变量名序列无星号但是左右长度不匹配，如`a,b="abcd"`
  * 左侧变量名序列星号的名称不在序列中，如`*a='abcd'`

### 元编程

管理属性的工具：`.__getattr__(self,name)`方法：拦截所有未定义属性的读取（它要么返回一个值，要么抛出`AttributeError`异常；`.__setattr__(self,name,value)`方法：拦截所有属性的读取赋值；`.__getattribute__(self,name)`方法：拦截所有属性的读取；`property`特性：将特定属性访问定位到`get`方法和`set`方法；描述符协议：将特定属性访问定位到具有任意`get`和`set`方法的实例对象。描述符：描述符是作为独立的类创建，它的实例是赋值给了类属性，描述符的实例可以由子类继承，描述符的实例管理一个单一的特定的属性，从技术上讲，`property()`创建的是一个描述符实例，描述符实例针对想要拦截的属性名访问操作，它提供了特定的方法。描述符类的接口为（即描述符协议）：

```python
class Descriptor:
	def __get__(self,instance,owner):
		pass
	def __set__(self,instance,value):
		pass
	def __delete__(self,instance):
		pass
class A:
	attr=Descriptor()
	...
```

* `instance`参数为：`None`：当用于类的属性访问时；类`A`的实例对象：当用于实例的属性访问时
* `owner`参数为：使用该描述符的类`A`
* 当访问类实例或者类属性时，自动调用该类的描述符实例的方法。如果该类的描述符中某些方法空缺则：若` __set__(self,instance,value)`未定义，则写该属性抛出`AttributeError`，该属性只读；若` __get__(self,instance,owner)`未定义，则读该属性返回一个`Descriptor`实例，因为从继承树中可知，该属性返回由类的`attr`变量名指定的对象
* 状态信息可以保持在实例对象中，也可以保存在描述符实例中。因为在这3个方法中，`self`,`instance`都可以访问

`.__delattr__(self,name)`方法拦截属性的删除

由于`.__getattribute__(self,name)`方法和`.__setattr__(self,name,value)`方法对所有的属性拦截，因此他们的实现特别要小心，注意不要触发无穷递归。

* `.__getattribute__(self,name)`方法中，若要取属性则可以用超类的`.__getattribute__(self,name)`获取。如果通过`.__dict__`方法获取则会再次触发`.__getattribute__(self,name)`的调用，因为`__dict__`本身就是对象的属性。
* `.__setattr__(self,name,value)`方法中，若要设置属性可以用`self.__dict__[name]=value`的方法，或者用超类的`.__setattr__(self,name,value)`方法
* 所有使用内置操作隐式的获取方法名属性，`.__getattr__(self,name)`、`.__setattr__(self,name,value)`、
  `.__getattribute__(self,name)`方法都不会拦截，因为Python在类中查找这样的属性，完全忽略了在实例中查找

属性拦截优先级：在读取属性方面，`__getattribute__`优先级最高；在写属性方面，`__setattr__`优先级最高；在删除属性方面，`__del__`优先级最高；如果没有`__getattribute__`，`__setattr__`与`__del__`，则读写删属性取决于描述符（`property`也是一种特殊的描述符）。其中如果同一个属性指定了多个描述符，则后面的描述符覆盖前面的描述符；`__getattribute__`与`__getattr__`区别：`__getattribute__`在任何属性读取的时候拦截，而`__getattr__`只有在未定义属性读取的时候拦截（约定俗成地，它要么返回一个值，要么返回`AttributeError`）。其中若二者同时存在则`__getattribute__`优先级较高

描述符的作用是用来代理一个类的属性，需要注意的是描述符不能定义在被使用类的构造函数中，只能定义为类的属性，它只属于类的，不属于实例。类的`__dict__`属性是类的一个内置属性，类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类`__dict__`里。在输出描述符的变量时，会调用描述符中的`__get__`方法，在设置描述符变量时，会调用描述符中的`__set__`方法。

 描述符分为数据描述符和非数据描述符。至少实现了内置`__set__()`和`__get__()`方法的描述符称为数据描述符；实现了除`__set__()`()以外的方法的描述符称为非数据描述符。描述符的优先级的高低顺序：类属性 > 数据描述符 > 实例属性 > 非数据描述符 > 找不到的属性触发`__getattr__()`。

函数在使用@property 装饰器装饰后，会变成类属性，而且会有一个 setter 方法，该方法也是一个装饰器，作用是装饰同属性(特性)的 set 函数。被装饰的函数必须与属性（被@property 装饰器装饰的函数）同名。当类函数被 @property 装饰时，实际上，这个函数已经成为了该类的特性，也就是该类的类属性了，这个过程在解释器导入该模块时就已经确定了。

#### 动态属性和特性

在 Python 中，数据的属性和处理数据的方法统称属性attribute。其实，方法只是可调用的属性。除了这二者之外，我们还可以创建特性property，在不改变类接口的前提下，使用存取方法即读值方法和设值方法修改数据属性仅当无法使用常规的方式获取属性即在实例、类或超类中找不到指定的属性，解释器才会调用特殊的 `__getattr__ `方法。`__new__`方法构造实例，返回`self`作为其他方法的实例使用。

```python
from collections import abc
class FrozenJSON:
    def __new__(cls, arg):
        if isintance(arg, abc.Mapping):
            return super().__new__(cls)
        elif isinstance(arg, abc.MutableSequence):
            return [cls(item) for item in arg]
        else: return arg
    def __init__(self, mapping):
        self._data = dict(mapping)
    def __getattr__(self, name):
        if hasattr(self._data, name):
            return getattr(self._data, name)
        else:
            return FrozenJSON(self._data[name])
```

`rozenJSON`类只有两个方法`__init__ `和 `__getattr__`和一个实例属性`__data`。因此，尝试获取其他属性会触发解释器调用`__getattr__`方法。我们通常把`__init__`称为构造方法。其实，用于构建实例的是特殊方法`__new__`：这是个类方法使用特殊方式处理，因此不必使用`@classmethod`装饰器，必须返回一个实例。返回的实例会作为第一个参数即self传给`__init__`方法。因为调用`__init__`方法时要传入实例，而且禁止返回任何值，所以`__init__`方法其实是“初始化方法”。真的构造方法是`__new__`。我们几乎不需要自己编写`__new__`方法，因为从`object`类继承的实现已经足够了。刚才说明的过程，即从`__new__`方法到`__init__`方法，是最常见的，但不是唯一的。`__new__`方法也可以**返回其他类的实例**，此时，解释器不会调用 `__init__ `

##### 使用动态属性转换数据类型

##### 特性全解析

`property(fget=None, fset=None, fdel=None, doc=None)`所有参数都是可选的，如果没有把函数传给某个参数，那么得到的特性对象就不允许执行相应的操作。特性都是类属性，但是特性管理的其实是实例属性的存取。实例属性不会遮盖类特性。新添的类特性遮盖现有的实例属性。`obj.attr`这样的表达式不会从`obj`开始寻找`attr`，而是从`obj.__class__`开始，而且，仅当类中没有名为`attr`的特性时，Python才会在`obj`实例中寻找。这条规则不仅适用于特性，还适用于一整类描述符——覆盖型描述符。

##### 处理属性的重要属性和函数

`vars([object])`返回`object`对象的`__dict__ `属性；如果实例所属的类定义了`__slots__`属性，实例没有`__dict__`属性，那么`vars`函数不能处理那个实例。如果没有指定参数，那么`vars()`函数的作用与`locals()`函数一样：返回表示本地作用域的字典。

##### 属性描述符

![](../picture/1/44.png)

描述符类：实现描述符协议的类。托管类：把描述符实例声明为类属性的类。描述符实例：描述符类的各个实例，声明为托管类的类属性。各个描述符实例使用箭头和带下划线的名称表示。与黑色菱形接触的`LineItem`类包含描述符实例。托管实例：托管类的实例。储存属性：托管实例中存储自身托管属性的属性。`LineItem`实例的`weight`和`price`属性是储存属性。这种属性与描述符属性不同，描述符属性都是类属性。托管属性：托管类中由描述符实例处理的公开属性，值存储在储存属性中。也就是说，描述符实例和储存属性为托管属性建立了基础。

实现`__set__ `方法的描述符属于覆盖型描述符，因为虽然描述符是类属性，但是实现
`__set__ `方法的话，会覆盖对实例属性的赋值操作。特性也是覆盖型描述符：如果没提供设值函数，`property`类中的`__set__`方法会抛出`AttributeError`异常，指明那个属性是只读的。通常，覆盖型描述符既会实现`__set__`方法，也会实现`__get__`方法，不过也可以只实现`__set__`方法。此时，只有写操作由描述符处理。通过实例读取描述符会返回描述符对象本身，因为没有处理读操作的`__get__`方法。如果直接通过实例的`__dict__`属性创建同名实例属性，以后再设置那个属性时，仍会由`__set__`方法插手接管，但是读取那个属性的话，就会直接从实例中返回新赋予的值，而不会返回描述符对象。也就是说，实例属性会遮盖描述符，不过只有读操作是如此。没有实现`__set__`方法的描述符是非覆盖型描述符。如果设置了同名的实例属性，描述符会被遮盖，致使描述符无法处理那个实例的那个属性。不管描述符是不是覆盖型，为类属性赋值都能覆盖描述符。这是一种猴子补丁技术，这其实会导致依赖描述符的类不能正确地
执行操作。

###### 方法是描述符

在类中定义的函数属于绑定方法，因为用户定义的函数都有`__get__`方法，所以依附到类上时，就相当于描述符。函数没有实现`__set__`方法，因此是非覆盖型描述符。与描述符一样，通过托管类访问时，函数的`__get__`方法会返回自身的引用。但是，通过实例访问时，函数的`__get__`方法返回的是绑定方法对象：一种可调用的对象，里面包装着函数，并把托管实例绑定给函数的第一个参数。绑定方法对象还有个`__call__`方法，用于处理真正的调用过程。这个方法会调用`__func__`属性引用的原始函数，把函数的第一个参数设为绑定方法的`__self__`属性。这就是形参 self 的隐式绑定方式。函数会变成绑定方法，这是 Python 语言底层使用描述符的最好例证。

**使用特性以保持简单**内置的`property`类创建的其实是覆盖型描述符，`__set__`方法和 `__get__ `方法都实现了，即便不定义设值方法也是如此。特性的`__set__`方法默认抛出`AttributeError: can't set attribute`，因此创建只读属性最简单的方式是使用特性。**只读描述符**必须有`__set__`方法如果使用描述符类实现只读属性，要记住，`__get__ `和`__set__`两个方法必须都定义，否则，实例的同名属性会遮盖描述符。只读属性的`__set__`方法只需抛出`AttributeError`异常，并提供合适的错误消息。**用于验证的描述符**可以只有`__set__`方法对仅用于验证的描述符来说，`__set__`方法应该检查`value`参数获得的值，如果有效，使用描述符实例的名称为键，直接在实例的`__dict__`属性中设置。这样，从实例中读取同名属性的速度很快，因为不用经过`__get__`方法处理。仅有`__get__`方法的描述符可以实现高效缓存如果只编写了`__get__`方法，那么创建的是非覆盖型描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例的`__dict__`属性中获取值，而不会再触发描述符的`__get__`方法。
**非特殊的方法可以被实例属性遮盖**由于函数和方法只实现了`__get__`方法，它们不会处理同名实例属性的赋值操作。因此，像`my_obj.the_method = 7`这样简单赋值之后，后续通过该实例访问`the_method`得到的是数字 7——但是不影响类或其他实例。然而，特殊方法不受这个问题的影响。解释器只会在类中寻找特殊的方法，也就是说，`repr(x)`执行的其实是`x.__class__.__repr__(x)`，因此`x`的`__repr__`属性对`repr(x)`方法调用没有影响。出于同样的原因，实例的`__getattr__`属性不会破坏常规的属性访问规则。