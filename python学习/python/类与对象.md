### 面向对象编程

Python中，类`class`与实例`instance`是两种不同的对象类型：类对象是实例对象的工厂；类对象与实例对象都有各自独立的命名空间；实例对象可自动存取类对象中的变量名；类属性为所有的实例对象提供状态和行为，它是由该类创建的所有实例对象共享的，每个实例对象都有自己的命名空间。同一个类的实例对象不一定属性都相同，每一个实例对象继承类的属性并创建了自己的命名空间，类创建的实例对象是有新的命名空间。刚开始该命名空间是空的，但它会继承创建该实例所属类对象的属性。继承的意思是，虽然实例对象的命名空间是空的。但是名字查找会自动上升到类对象的名字空间去查找，可以在`class`语句外创建类对象的新属性，通过向类对象直接赋值来实现。

类可以继承。被继承的类称为超类，继承类称为子类。类对象会继承其超类对象中定义的所有类属性名称，类对象的 `.__dict__`属性是类对象的命名空间，是一个类字典对象`mappingproxy`对象 ； 实例对象的 `.__dict__`属性是实例对象的命名空间，是一个字典； 实例对象的`.__class__`属性是它所属的类，类对象的`__bases__`属性是它超类对象的元组，类对象的`__name__`属性是类名，在子类中调用超类的方`superClass.func(obj,args)`，其中`obj`通常为`self` ，`self`使得可以使用子类的属性，在子类中重载父类方法。

若子类重新定义了超类的变量名，子类会取代并定制所继承的行为。这称为重载。在Python中，当对象通过点号运算读取属性值时就会发生继承，而且涉及了搜索属性定义树。每次使用`name.attr`时(`name`为实例对象或者类对象），Python会从底部向上搜索命名空间树。先从本对象的命名空间开始，一直搜索到第一个找到的`attr`名字就停止，命名空间树中较低位置处的定义会覆盖较高位置处的定义，继承树的搜索仅仅发生在读取属性值的时候。在写属性值时，执行的是属性的定义(当前命名空间中该名字不存在)或赋值(当前命名空间中该名字已存在)语义。

~~~mermaid
graph BT;
A(实例命名空间)-->B[类命名空间];
B-->C[超类1命名空间];
B-->D[超类2命名空间];
style A fill:#f9f,stroke:#333;
~~~

在`Python3`中所有的类都是新式类。所有的类都是从`object`内置类派生而来，`type(obj)`返回对象实例所属的类对象，`type(classname)`返回`"type"`，因为所有`class`对象都是`type`的实例，由于所有`class`均直接或者间接地派生自`object`类，因此每个实例对象都是`object`类的实例，`object`是`type`类的实例，但是同时`type`又派生自`object`。`Python3`中的类有一个`.__slots__`属性，它是一个字符串列表。这个列表限定了类的实例对象的合法属性名。如果给实例赋了一个`.__slots__`列表之外的属性名会引发异常，当有`.__slots__`列表存在时，默认会删除`.__dict__`属性，而`getattr()`，`setattr()`以及`dir()`等函数均使用`.__slots__`属性，因此仍旧可以正常工作，在继承中: 若子类继承自一个没有`.__slots__`的超类，则超类的`.__dict__`属性可用，则子类中的`.__slots__`没有意义。因为子类继承了超类的`.__dict__`属性，若子类有`.__slots__`，超类也有`.__slots__`，子类的合法属性名为父类和子类的`.__slots__`列表的并集，若超类有`.__slots__`，子类未定义`.__slots__`，则子类将会有一个`.__dict__`属性

```python
  class A:
    	def __init__(self):
        	self._x = None
    	@property #定义了一个property get函数，必选
    	def x(self): # property name 就是 get函数的函数名
        	return self._x
    	@x.setter #定义了一个property set函数，可选
    	def x(self, value):
        	self._x = value
```

总结一下，类中可以定义四种方法：

- 普通方法：方法就是类对象的一个属性，执行常规函数调用语义`classname.method(args)`
- 实例方法：传入一个实例作为方法的第一个实参。调用时可以：`obj.method(args)`:通过实例调用、`classname.method(obj,args)`：通过类调用
- `staticmethod`方法：当以实例对象调用`staticmethod`方法时，Python并不会将实例对象传入作为参数；而普通的实例方法，通过实例对象调用时，Python将实例对象作为第一个参数传入，静态方法是类中的函数，不需要实例。静态方法主要是用来存放逻辑性的代码，逻辑上属于类，但是和类本身没有关系，也就是说在静态方法中，不会涉及到类中的属性和方法的操作。可以理解为，静态方法是个独立的、单纯的函数，它仅仅托管于某个类的名称空间中，便于使用和维护。	
- `classmethod`方法：当以实例对象或者类对象调用`classmethod`方法时，Python将类对象（如果是实例对象调用，则提取该实例所属的类对象）传入函数的第一个参数`cls`中		

类的实例方法中，用哪个实例调用的该方法，`self`就是指向那个实例对象，类的`classmethod`方法中，用哪个类调用该方法，`cls`就指向那个类对象。类对象与实例对象都是可变对象，可以给类属性、实例属性进行赋值，这就是原地修改。这种行为会影响对它的多处引用。若类的某个属性是可变对象，则对它的修改会立即影响所有的实例对象。多重继承中，超类在`class`语句首行内的顺序很重要。Python搜索继承树时总是根据超类的顺序，从左到右搜索超类。类对象的`.__mro__`属性。它是一个`tuple`，里面存放的是类的实例方法名解析时需要查找的类。Python根据该元组中类的前后顺序进行查找。类对象的`.__mro__`列出了`getattr()`函数以及`super()`函数对实例方法名字解析时的类查找顺序。

`super()`函数：`super()`返回一个`super`实例对象，它用于代理实例方法/类方法的执行：`super(class,an_object)`：要求`isinstance(an_object,class)`为真。代理执行了实例方法调用；`super(class,class2)`：要求 `issubclass(class2,class)`为真。代理执行了类方法调用

有两种特殊用法：`super(class)`：返回一个非绑定的`super`对象，在类的实例方法中，直接调用`super()`，等价于`super(classname,self)`，这里`self`可能是`classname`子类实例，在类的类方法中，直接调用`super()`，等价于`super(classname,cls)`（这里`cls`可能是`classname`子类）

原理：`super`的原理类似于：首先从`mro`中找到对应的`cls`然后从这个开始寻找对应的方法。

``` python
def super(cls,instance):
	mro=instance.__class__.__mro__ #通过 instance生成 mro
	return mro[mro.index(cls)+1] #查找cls在当前mro中的index,返回cls的下一个元素
```

```python
class Root:
	def method1(self):
		print("this is Root")
class B(Root):
	def method1(self):
		super(B,self).method1() #也可以简写为 super().method1()
class C(Root):
	def method1(self):
		super().method1() #也可以写成super(C,self).method1()
class D(B,C):
	pass
```

调用`D().method1()`--> `D`中没有`method1` ；`B`中找到（查找规则：`D.__mro__`)  --> 执行`B`中的`method1`。此时`self`为D实例。`D.__mro__`中，`B`的下一个是`C`，因此`super(B,self）.method1()`从类`C`中查找`method1`；执行`C`的`method1`。此时`self`为D实例。`D.__mro__`中，`C`的下一个是`Root`，因此`super(C,self）.method1()`从类`Root`中查找`method1`；执行`Root`的`method1`；`print(self)`可以看到，这里的`self`全部为 `D`的实例

在面向对象的术语中，通常描述现有的类为基类、父类或者超类，而称新定义的类为子类。有两种方式可以让子类有别于父类。子类可以通过提供一个新的覆盖现有方法的实现方法特化一个现有的行为。子类也可以通过提供一些权限的方法扩展其父类。如一个类的唯一目的是作为继承的基类，那么这个类就是一个抽象基类。更正式地说，一个抽象类不能直接实例化，而具体的类可以被实例化。

封装：将内部实现包裹起来，对外透明，提供`api`接口进行调用的机制。将数据与具体操作的实现代码放在某个对象内部，外部无法访问。必须要先调用类的方法才能启动。
继承：即一个派生类继承父类的变量和方法。
多态：根据对象类型的不同以不同的方式进行处理。

###### 魔法方法

| 魔法方法                         | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `__module__`                     | 前者表示当前操作对象在属于那个模块；                         |
| `__call__(self[, args...])`      | 允许一个类的实例像函数一样被调用：`x(a, b) `调用` x.__call__(a, b)` |
| `__getattr__(self, name)`        | 定义当用户试图获取一个不存在的属性时的行为                   |
| `__setattr__(self, name, value)` | 定义当一个属性被设置时的行为                                 |
| `__getitem__(self, key)`         | 定义获取容器中指定元素的行为，相当于` self[key]`             |
| `__setitem__(self, key, value)`  | 定义设置容器中指定元素的行为，相当于 `self[key] = value`     |
| `__delitem__(self, key)`         | 定义删除容器中指定元素的行为，相当于` del self[key]`         |
| `__contains__(self, item)`       | 定义当使用成员测试运算符`in` 或` not in`时的行为             |
| `__reversed__(self)`             | 定义当被 `reversed() `调用时的行为                           |
| `__bases__`                      | 获取指定类的所有父类构成元素，使用方法为类名`.__bases__`·    |
| `__hash__(self)`                 | 定义当被` hash() `调用时的行为                               |

##### 元类

所有用户定义的类都是`type`类对象的实例，`type`类是应用最广的元类。`class`语句的内部机制：在一条`class`语句的末尾，Python会调用`type`类的构造函数来创建一个`class`对象。

```python
MyClass=type(classname,superclasses,attributedict) #新建了一个类，类名叫MyClass
# classname:类名，会成为MyClass类的 .__name__属性
# superclasses:类的超类元组，会成为MyClass类的 .__bases__属性
# attributedict:类的命名空间字典，会成为MyClass类的 .__dict__ 属性
```

`type`类定义了一个`.__call__(...)`方法。该方法运行`type`类定义的两个其他方法：

* `.__new__(mclass,classname,superclasses,attributedict)`方法，它返回新建的`MyClass`类，`mclass`：为本元类，这里是`type`类，`classname`：为被创建的类的类名，这里是`'MyClass'`，`superclasses`：为被创建的类的超类元组，`attributedict`：为被创建的类的名字空间字典  
* `.__init__(customclass,classname,superclasses,attributedict)`方法，它初始化新建的`MyClass`类，`customclass`：为被创建的类，这里是`MyClass`类，`classname`：为被创建的类的类名，这里是`'MyClass'`，`superclasses`：为被创建的类的超类元组，`attributedict`：为被创建的类的名字空间字典  

所有的类型均由`type`类创建。要通知Python用一个定制的元类来创建类，可以直接声明一个元类来拦截常规的类创建过程。所有元类必须是`type`的子类

```python
class MetaClass(type):
	def __new__(mclass,classname,superclasses,attributedict):		
		return type.__new__(mclass,classname,superclasses,attributedict)
	def __init__(customclass,classname,superclasses,attributedict):
		return type.__init__(customclass,classname,superclasses,attributedict)
class MyClass(metaclass=MetaClass):
	pass
```

继承的超类也列在括号中，但是要在元类之前，也用逗号分隔：`class MyClass(BaseCls1,BaseCls2,metaclass=MetaClass)`。使用元类声明后，在`class`语句底部进行创建`MyClass`类时，改为调用元类`MetaClass`而不是默认的`type`：`MyClass=Meta('MyClass',superclasses,attributedict)`

* 元类`MetaClass`要实现元类协议：重载元类的`.__new__(Meta,classname,superclasses,attributedict)`方法，它返回新建的`MyClass`类；重载元类的`.__init__(customclass,classname,superclasses,attributedict)`方法，
  它初始化新建的`MyClass`类，`type`类的`.__call__(...)`方法将创建和初始化`MyClass`类对象的调用委托给元类``MetaClass`

事实上元类只用于创建类对象，元类并不产生元类自己的实例。因此元类的名字查找规则有些不同：`.__call__`，`.__new__`，`.__init__`方法均在类中查找；元类的继承：元类声明由子类继承，即子类的构建也是由父类的元类负责，如果元类是以函数的方式声明，则子类的构建不再继承这个函数式元类；元类中的属性并不进入自定义类的命名空间，即元类中声明的一些类属性与被创建类的名字空间无关，自定义的类，如果没有显示指定元类，也没有指定父类，则默认使用`type`作为元类

##### 对象引用、可变性和垃圾回收

每个对象至少包含三个数据：引用计数、类型、值。引用计数用于内存管理。类型在`CPython`层使用，用于确保运行时的类型安全性。最后，值，即与对象关联的实际值。`id()`返回对象的内存地址。`is `当且仅当两个对象具有相同的内存地址时才返回True。

###### C中变量

```c
int x=2337	
```

这一行代码在执行时有几个不同的步骤：为整数分配足够的内存；将值分配2337给该内存位置；指示x指向该值； 以简化的内存视图显示，它可能如下所示： 

![](../picture/work/37.png)

另一种思考这个概念的方法是在所有权方面。从某种意义上说，`x`拥有内存位置。首先，`x`恰好是一个可以存储整数的空盒子，可以用来存储整数值。当您给`x`赋值时，您将向`x`拥有的盒子中放入一个值。如果你想引入一个新的变量`y`，

```c
int y=x
```

![](../picture/work/38.png)

###### python中的名称

``` python
x=2337
```

与`C`类似，python在执行过程中分解为几个不同的步骤：创建一个`PyObject`；将`PyObject`的`typecode`设置为整数`PyObject`；将`PyObject`的值设置为2337；创建一个名称`x`；将`x`指向新的`PyObject`；将`PyObject`引用计数增加`1`

![](../picture/work/39.png)

```python
x=2338
```

这行代码：创建一个新的`PyObject`；将`PyObject`的`typecode`设置为整数；将`PyObject`的值设置为2338；将`x`指向新的`PyObject`；将新的`PyObject`引用计数增加1；将旧的`PyObject`引用计数减少1

![](../picture/work/40.png)

```python
y=x
```

![](../picture/work/41.png)

Python在内存中预先创建了某个对象子集，并将它们保存在全局命名空间中以供日常使用。哪些对象依赖于Python的预实现。`CPython 3.7`预实现对象如下：-5到256之间的整数；仅包含ASCII字母，数字或下划线的字符串。这背后的原因是这些变量很可能在许多程序中使用。通过预先实现些对象，Python可以防止对一致使用的对象进行内存分配调用。

当标识符a和b是同一个对象的别名时，表达式`a is b`的结果为真，表达式`a==b`是一个更一般的等价概念。如果标识符a和b指向同一个对象，那么表达式`a==b`为真。如果标识符指向不同的对象，但这些对象的值被认为是等价的，那么`a==b`的结果也为真。精确的等价概念取决于数据类型。

python中的赋值语句不会创建对象的副本，而只是给对象绑定了新的名称。浅拷贝会创建一个新的集合对象，然后用原对象的引用来填充它。实质上，浅拷贝只有一层。拷贝过程不会递归，因此不会创建子对象本身的副本。深拷贝会递归拷贝过程。这意味着会首先构造一个新的集合对象，然后递归地填充原始对象中的子对象的副本。以这种方式拷贝对象会遍历整个对象树，从而创建原始对象及其所有子对象的完全独立的副本。

所有python对象拥有三个属性：身份、类型、值。可变对象值值可变，身份不可变；不可变对象指身份和值都不可变。每个对象都会在内存中申请一块空间来保存该对象，该对象在内存中所在位置的地址被称为引用。在开发程序时，所定义的变量名实际就是对象的地址引用。赋值的本质就是让多个变量同时引用同一个对象的地址。引用实际就是内存中的一个数字地址编号，在使用对象时，只要知道这个对象的地址，就可以操作这个对象，但是因为这个数字地址不方便在开发时使用和记忆，所以使用变量名的形式来代替对象的数字地址。 在 Python 中，变量就是地址的一种表示形式，并不开辟开辟存储空间。

可变对象和不可变对象在拷贝时情况是不一样的：不可变对象的拷贝只在修改的时候才会在内存中开辟新的空间，而拷贝实际上是让多个对象同时指向同一个引用，和对象赋值没有区别。可变对象在浅拷贝时只拷贝第一层中的引用，深拷贝时，会逐层拷贝，直到所有的引用都是不可变对象位置。

![](../picture/1/32.png)

理解 Python 中的赋值语句，应该始终先读右边。对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。因为变量只不过是标注，所以无法阻止为对象贴上多个标注。贴的多个标注，就是别名。每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理解为对象在内存中的地址。Python 唯一支持的参数传递模式是共享传参。共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识

##### `del`和垃圾回收

`del `语句删除名称，而不是对象。`del `命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。 重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。在 `CPython `中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少引用指向自己。当引用计数归零时，对象立即就被销。`CPython 2.0 `增加了分代垃圾回收算法，用于检测引用循环中涉及的对象组——如果一组对象之间全是相互引用，即使再出色的引用方式也会导致组中的对象不可获取。正是因为有引用，对象才会在内存中存在。当对象的引用数量归零后，垃圾回收程序会把对象销毁。

内存泄漏- 这里的泄漏，并不是说你的内存出现了信息安全问题，被恶意程序利用了，而是指程序本身没有设计好，导致程序未能释放已不再使用的内存。- 内存泄漏也不是指你的内存在物理上消失了，而是意味着代码在分配了某段内存后，因为设计错误，失去了对这段内存的控制，从而造成了内存的浪费。也就是这块内存脱离了gc的控制

当一个对象不再调用的时候，也就是当这个对象的引用计数为 0 的时候，说明这个对象永不可达，自然它也就成为了垃圾，需要被回收。可以简单的理解为没有任何变量再指向它。python针对循环引用，有它的自动垃圾回收算法1. 标记清除算法、2. 分代收集。标记清除的步骤总结为如下步骤1. `GC`会把所有的活动对象打上标记；2. 把那些没有标记的对象非活动对象进行回收/对于一个有向图，如果从一个节点出发进行遍历，并标记其经过的所有节点；那么，在遍历结束后，所有没有被标记的节点，我们就称之为不可达节点。显而易见，这些节点的存在是没有任何意义的，自然的，我们就需要对它们进行垃圾回收。但是每次都遍历全图，对于 Python 而言是一种巨大的性能浪费。所以，在 Python 的垃圾回收实现中，mark-sweep 使用双向链表维护了一个数据结构，并且只考虑容器类的对象。分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。

#### 序列的修改、散列和切片

Python 的序列协议只需要 `__len__ `和 `__getitem__ `两个方法。任何类，只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。

调用`dir(slice)`得到的结果中有个`indices`属性，`S.indices(len) -> (start, stop, stride)`给定长度为` len`的序列，计算 S 表示的扩展切片的起始和结尾索引，以及步幅。超出边界的索引会被截掉，这与常规切片的处理方式一样。换句话说，`indices` 方法开放了内置序列实现的棘手逻辑，用于优雅地处理缺失索引和负数索引，以及长度超过目标序列的切片。这个方法会“整顿”元组，把` start、stop` 和`stride` 都变成非负数，而且都落在指定长度序列的边界内。

`my_seq[a:b:c]` 句法背后的工作原理：创建 `slice(a, b, c)`对象，交给` __getitem__ `方法处理。`a:b:c `这种用法只能作为索引或者下标用在` [] `中来返回一个切片对象：`slice(a, b,c)`。对 `seq[start:stop:step] `进行求值的时候，Python 会调用`seq.__getitem__(slice(start, stop, step))`。要正确处理这种` [] `运算符的话，对象的特殊方法 `__getitem__ `和 `__setitem__ `需要以元组的形式来接收`a[i, j] `中的索引。也就是说，如果要得到 `a[i, j] `的值，Python 会调用`a.__getitem__((i, j))`。

#### 从协议到抽象基类

鸭子类型：对象的类型无关紧要，只要实现了特定的协议即可。猴子补丁：在运行时修改类或模块，而不改动源码。猴子补丁很强大，但是打补丁的代码与要打补丁的程序耦合十分紧密，而且往往要处理隐藏和没有文档的部分。白鹅类型指，只要`cls`是抽象基类，即`cls`的元类是`abc.ABCMeta`，就可以使用`isinstance(obj, cls)`。

![](../picture/1/34.png)

`Iterable、Container `和 `Sized`:各个集合应该继承这三个抽象基类，或者至少实现兼容的协议。`Iterable `通过
`__iter__ `方法支持迭代，`Container`通过 `__contains__ `方法支持`in `运算符，`Sized`通过 `__len__ `方法支持 `len() `函数。`Sequence、Mapping `和 `Set`这三个是主要的不可变集合类型，而且各自都有可变的子类。`Callable `和 `Hashable`这两个抽象基类与集合没有太大的关系，只不过因为` collections.abc `是标准库中定义抽象基类的第一个模块，而它们又太重要了，因此才把它们放到`collections.abc`模块中。我从未见过`Callable`或`Hashable`的子类。这两个抽象基类的主要作用是为内置函数`isinstance`提供支持，以一种安全的方式判断对象能不能调用或散列。

##### 运算符重载

Python中所有可以被重载的方法名称前、后均有两个下划线字符，以便将它与其他类内定义的名字区分开来，如`__add__`；若使用未定义运算符重载方法，则它可能继承自超类。若超类中也没有则说明你的类不支持该运算，强势使用该运算符则抛出异常  

`.__init__(self,args)`方法：称为构造函数。当新的实例对象构造时，会调用`.__init__(self,args)`方法。它用于初始化实例的状态  

`.__getitem__(self,index)`和`.__setitem(self,index,value)__`方法：对于实例对象的索引运算，会自动调用`.__getitem__(self,index)`方法，将实例对象作为第一个参数传递，方括号内的索引值传递给第二个参数;对于分片表达式也调用`.__getitem__(self,index)`方法。实际上分片边界如`[2:4]`绑定到了一个`slice`分片对象上，该对象传递给了`.__getitem__`方法。  对于带有一个`.__getitem__`方法的类，该方法必须既能针对基本索引（一个整数），又能针对分片调用（一个`slice`对象作为参数；`.__getitem__(self,index)`也是Python的重载迭代方式之一。一旦定义了这个方法，`for`循环每一次循环时可以调用`.__getitem__(self,index)`方法。因此任何响应了索引运算的内置或者用户自定义的实例对象通用可以响应迭代。

`.__setitem(self,index,value)__`方法类似地拦截索引赋值和分片赋值。第一个参数为实例对象，第二个参数为基本索引或者分片对象，第三个参数为值  

`.__index__(self)`方法：该方法将实例对象转换为整数值。即当要求整数值的地方出现了实例对象时自行调用。  

`.__getattr__(self,'name')`方法：拦截属性点号运算`obj.name`。只有当对未定义的属性名称进行点号运算时，实例对象会调用此方法，当Python可以从继承树中找到该属性名时，并不会调用`.__getattr__(self,'name')`方法，属性不仅仅是变量名，也可以是方法名，内置的`getattr(obj,'name')`函数等价于调用`obj.name`，它执行继承搜索。搜不到时调用`.__getattr__(self,“name”)`方法，如果没有定义`.__getattr__(self,“name”)`方法，则对于不知道如何处理的属性，则Python抛出内置的`AttributeError`异常  

`.__setattr__(self,'name',value)`方法：拦截所有的属性赋值语句对于属性赋值语句，因为如果该属性曾经不存在，则一旦赋值就增加了一个新的属性，属性不仅仅是变量名，也可以是方法名，注意：`.__setattr__(self,'name',value)`方法的函数体内，任何对`self`属性赋值语句(`self.name=value`)都会再次递归调用`.__setattr__(self,'name',value)`函数，为了防止`.__setattr__(self,'name',value)`函数体内的无穷递归，在该方法内的`self`属性赋值要采用属性字典索引的方法：`self.__dict__['name']=value`，内置的`setattr(obj,'name',value)`函数等价于调用`obj.name=value`

`.__getattribute__(self,'name')`方法：拦截所有的属性读取，而不仅仅是那些未定义的。注意：`.__getattribute__(self,'name')`方法的函数体内，任何对`self`属性读取语句(`self.name`)都会再次递归调用`.__getattribute__(self,'name')`函数。尽量不要重载`.__getattribute__(self,'name')`方法避免无穷递归

通过`.__getattr__`与`.__setattr__`方法混合使用可以模拟实例对象的私有属性：实例对象保存一个`self.private`变量名列表，对`.__setattr__`与`.__getattr__`，判断属性名是否在`self.private`变量名列表中。若是，则抛出异常

`.__call__(self,*pargs,**kwargs)`方法：函数调用方法。当调用实例对象时，由`.__call__(self,*pargs,**kwargs)`方法拦截。`.__call__(self,*pargs,**kwargs)`方法支持所有的参数传递方式 

运算符重载的作用是让用户定义的对象使用中缀运算符如`+`和`|`或一元运算符如`-`和`~`。说得宽泛一些，在 Python 中，函数调用`()`、属性访问`.`和元素访问 / 切片`[]`也是运算符。不能重载内置类型的运算符；不能新建运算符，只能重载现有的；某些运算符不能重载`is、and、or`和`not`

| 类别               | 方法名和对应的运算符                                         |
| ------------------ | ------------------------------------------------------------ |
| 一元运算符         | `__neg__ -、__pos__ +、__abs__ abs()`                        |
| 众多比较运算符     | `__lt__ <、__le__ <=、__eq__ ==、__ne__ !=、__gt__ >、__ge__ >=` |
| 算术运算符         | `__add__ +、__sub__ -、__mul__ *、__truediv__ /、__floordiv__ //、__mod__ %、__divmod__<br/>divmod()、__pow__ ** 或pow()、__round__ round()` |
| 反向算术运算符     | `__radd__、__rsub__、__rmul__、__rtruediv__、__rfloordiv__、__rmod__、__rdivmod__、__rpow__` |
| 增量赋值算术运算符 | `__iadd__、__isub__、__imul__、__itruediv__、__ifloordiv__、__imod__、__ipow__` |
| 位运算符           | `__invert__ ~、__lshift__ <<、__rshift__ >>、__and__ &、__or__` |
| 反向位运算符       | `__rlshift__、__rrshift__、__rand__、__rxor__、__ror__`      |
| 增量赋值位运算符   | `__ilshift__、__irshift__、__iand__、__ixor__、__ior__`      |

跟运算符无关的特殊方法

| 类别                    | 方法名                                                       |
| ----------------------- | ------------------------------------------------------------ |
| 字符串/字节序列表示形式 | `__repr__、__str__、__format__、__bytes__`                   |
| 数值转换                | `__abs__、__bool__、__complex__、__int__、__float__、__hash__、__index__` |
| 集合模拟                | `__len__、__getitem__、__setitem__、__delitem__、__contains__` |
| 迭代枚举                | `__iter__、__reversed__、__next__`                           |
| 可调用模拟              | `__call__`                                                   |
| 上下文管理              | `__enter__、__exit__`                                        |
| 实例创建和销毁          | `__new__、__init__、__del__`                                 |
| 属性管理                | `__getattr__、__getattribute__、__setattr__、__delattr__、__dir__` |
| 属性描述符              | `__get__、__set__、__delete__`                               |
| 跟类相关的服务          | `__prepare__、__instancecheck__、__subclasscheck__`          |

Python 为中缀运算符特殊方法提供了特殊的分派机制。对表达式`a + b`来说，解释器会执行以下几步操作。(1) 如果`a`有`__add__`方法，而且返回值不是 `NotImplemented`，调用`a.__add__(b)`，然后返回结果。(2) 如果`a`没有`__add__ `方法，或者调用`__add__ `方法返回`NotImplemented`，检查`b`有没有 `__radd__ `方法，如果有，而且没有返回`NotImplemented`，调用`b.__radd__(a)`，然后返回结果。(3) 如果`b`没有`__radd__`方法，或者调用`__radd__`方法返回`NotImplemented`，抛出`TypeError`，并在错误消息中指明操作数类型不支持。

![](../../picture/1/43.png)