### 控制流程

可迭代对象：在逻辑上它保存了一个序列，在迭代环境中依次返回序列中的一个元素值。迭代协议：`.__next__()`方法。任何对象只要实现了迭代协议，则它就是一个迭代器对象，迭代器对象调用`.__next__()`方法，会得到下一个迭代结果，在一系列迭代之后到达迭代器尾部，若再次调用`.__next__()`方法，则会触发`StopIteration`异常，迭代器在Python中是用C语言的速度运行的，因此速度最快。内置的`iter()`函数用于从序列、字典、`set`以及其他可迭代对象中获取迭代器。对任何迭代器对象`iterator`，调用`iter(iterator)`返回它本身，迭代器对象实现了迭代协议，文件对象本身是一个迭代器对象。即文件对象实现了迭代协议，因此打开多个文件会返回同一个文件对象，列表、元组、字典、`set`、字符串等不适迭代器对象，他们没有实现迭代协议。因此每次调用`iter()`均返回一个新迭代器对象。他们支持安装多个迭代器，每个迭代器状态不同，在原地修改列表、`set`、字典时，会实时反映到它们的迭代器上。`range`对象不支持`.__next__()`，因此它本身不是迭代器，而`map`、`zip`、`filter`对象都是迭代器。字典的视图：键视图、值视图、字典视图都没有`.__next__()`方法，因此他们都不是迭代器  

Python的所有迭代环境都会首先尝试调用`.__iter__(self)`方法，再尝试调用`.__getitem__(self,index)`方法。要让实例对象支持多个迭代器，`.__iter__(self)`方法必须创建并返回新的迭代器对象。

* `.__iter__(self)`方法必须返回一个迭代器对象。Python的迭代环境通过重复调用这个迭代器对象的`.__next__(self)`方法，直到发生了`StopIteration`异常。`.__iter__(self)`返回的迭代器对象会在调用`.__next__(self)`的过程中明确保留状态信息，因此比`.__getitem__(self,index)`方法具有更好的通用性，迭代器对象没有重载索引表达式，因此不支持随机的索引运算。`.__iter__(self)`返回的迭代器只能顺序迭代一次。因此每次要进行新的一轮循环时必须创建一个新的迭代器对象
* 对于调用`.__getitem__(self,index)`的环境，Python的迭代环境通过重复调用该方法，其中`index`每轮迭代中从 0 依次递增，直到发生了`IndexError`异常  

类通常把`in`成员关系运算符实现为一个迭代，用`.__iter__(self)`方法或`.__getitem__(self,index)`方法。也能实现`.__contains__(self,value)`方法来实现特定成员关系。`.__contains__(self,value)`方法优先于`.__iter__(self)`方法，`.__iter__(self)`方法优先于`.__getitem__(self,index)`方法采纳  

#### 可迭代对象、迭代器和生成器

迭代是数据处理的基石。扫描内存中放不下的数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项。这就是迭代器模式。所有生成器都是迭代器，因为生成器完全实现了迭代器接口。迭代器用于从集合中取出元素；而生成器用于“凭空”生成元素。在Python中，所有集合都可以迭代。

可迭代的对象使用`iter`内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的`__iter__ `方法，那么对象就是可迭代的。序列都可以迭代；实现了 `__getitem__ `方法，而且其参数是从零开始的索引，这种对象也可以迭代。标准的迭代器接口有两个方法。`__next__`返回下一个可用的元素，如果没有元素了，抛`StopIteration`异常。`__iter__`返回`self`，以便在应该使用可迭代对象的地方使用迭代器

![](../picture/1/38.png)

只要Python函数的定义体中有`yield`关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。生成器函数会创建一个生成器对象，包装生成器函数的定义体。把生成器传给`next(...) `函数时，生成器函数会向前，执行函数定义体中的下一个`yield`语句，返回产出的值，并在函数定义体的当前位置暂停。最终，函数的定义体返回时，外层的生成器对象会抛出`StopIteration`异常——这一点与迭代器协议一致。

##### 标准库中的生成器函数

###### 用于过滤的生成器函数

| 函数                                      | 说明                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| `itertools.compress(it, selector_it)`     | 并行处理两个可迭代的对象；如果`selector_it`中的元素是真值，产出`it`中对应的元素 |
| `itertools.dropwhile(predicate, it)`      | 处理`it`，跳过`predicate`的计算结果为真值的元素，然后产出剩下的各个元素 |
| `itertools.filterfalse(predicate, it)`    | 与`filter`函数的作用类似，不过`predicate`的逻辑是相反的：`predicate`返回假值时产出对应的元素 |
| `itertools.islice(it, start, stop, step)` | 产出`it`的切片，作用类似于`s[start:stop:step]`，不过`it`可以是任何可迭代的对象，而且这个函数实现的是惰性操作 |
| `itertools.takewhile(predicte, it)`       | `predicate`返回真值时产出对应的元素，然后立即停止，不再继续检查。 |

###### 用于映射的生成器函数

| 函数                              | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `itertools.accumulate(it[,func])` | 产出累积的总和；如果提供了`fun`，那么把前两个元素传给它，然后把计算结果和下一个元素传给它，以此类推，最后产出结果 |
| `enumerate(iterable, start = 0)`  | 产出由两个元素组成的元组，结构是`(index, item)`，其中`index`从`start`开始计数，`item`则从`iterable`中获取 |
| `map(func, it1[, it2, ..., itN])` | 把`it`中的各个元素传给`func`，产出结果；如果传入`N`个可迭代的对象，那么`func`必须能接受`N`个参数，而且要并行处理各个可迭代的对象 |
| `itertools.starmap(func, it)`     | 把`it`中的各个元素传给`func`，产出结果；输入的可迭代对象应该产出可迭代的元素`iit`，然后以`func(*iit)`这种形式调用`func` |

###### 合并多个可迭代对象的生成器函数

| 函数                                                   | 说明                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| `itertools.chain(it1, ..., itN)`                       | 先产出`it1`中的所有元素，然后产出`it2`中的所有元素，以此类推，无缝连接在一起 |
| `itertools.chain.from_iterable(it)`                    | 产出`it`生成的各个可迭代对象中的元素，一个接一个，无缝连接在一起；`it`应该产出可迭代的元素。 |
| `itertools.product(it1, ..., itN, repeat =1)`          | 计算笛卡儿积：从输入的各个可迭代对象中获取元素，合并成由 `N`个元素组成的元组，与嵌套的`for`循环效果一样；`repeat`指明重复处理多少次输入的可迭代对象 |
| `zip(it1, ..., itN)`                                   | 并行从输入的各个可迭代对象中获取元素，产出由`N`个元素组成的元组，只要有一个可迭代的对象到头了，就默默地停止 |
| `itertools.zip_longest(it1, ..., itN, fillvalue=None)` | 并行从输入的各个可迭代对象中获取元素，产出由`N`个元素组成的元组，等到最长的可迭代对象到头后才停止，空缺的值使用`fillvalue`填充 |

###### 把输入的各个元素扩展成多个输出元素的生成器函数

| 函数                                                   | 说明                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| `itertools.combination(it, out_len)`                   | 把`it`产出的`out_len`个元素组合在一起，然后产出              |
| `itertools.combinations_with_replacement(it, out_len)` | 把`it`产出的`out_len`个元素组合在一起，然后产出，包含相同元素的组合 |
| `itertools.count(start=0, step=1)`                     | 从`start`开始不断产出数字，按`step`指定的步幅增加            |
| `itertools.cycle(it)`                                  | 从`it`中产出各个元素，存储各个元素的副本，然后按顺序重复不断地产出各个元素 |
| `itertools.permutation(it, out_len=None)`              | 把`out_len`个`it`产出的元素排列在一起，然后产出这些排列；`out_len`的默认值等于`len(list(it))` |
| `itertools.repeat(item[, times])`                      | 重复不断地产出指定的元素，除非提`times`，指定次数            |

###### 用于重新排列元素的生成器函数

| 函数                                    | 说明                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| `itertools.groupby(iter, key = None)`   | 产出由两个元素组成的元素，形式为`(key, group)`，其中`key`是分组标准，`group`是生成器，用于产出分组里的元素 |
| `itertools.tee(it, n =2)`               | 产出一个由`n`个生成器组成的元组，每个生成器用于单独产出输入的可迭代对象中的元素 |
| `functools.reduce(func, it[, initial])` | 把前两个元素传给`func`，然后把计算结果和第三个元素传给 `func`，以此类推，返回最后的结果；如果提供了`initial`，把它当作第一个元素传入 |

`iter`函数还有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调用的对象创建迭代器。这样使用时，第一个参数必须是可调用的对象，用于不断调，产出各个值；第二个值是哨符，这是个标记值，当可调用的对象返回这个值时，触发迭代器抛出`StopIteration`异常，而不产出哨符。

#### 上下文管理和`else`块

`for/else、while/else `和 `try/else `的语义关系紧密，不过与`if/else`差别很大。`for`仅当 `for `循环运行完毕时才运行`else`块。`while`仅当`while`循环因为条件为假值而退出时才运行`else`块。`try`仅当`try `块中没有异常抛出时才运行`else`块。在所有情况下，如果异常或者`return、break`或`continue`语句导致控制权跳到了复合
语句的主块之外，`else`子句也会被跳过。

上下文管理器对象存在的目的是管理`with`语句，就像迭代器的存在是为了管理`for`语句一样。`with`语句的目的是简化`try/finally `模式。这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、`return `语句或 `sys.exit() `调用而中止，也会执行指定的操作。`finally `句中的代码通常用于释放重要的资源，或者还原临时变更的状态。上下文管理器协议包含 `__enter__ `和 `__exit__ `两个方法。`with `语句开始运行时，会在上下文管理器对象上调用 `__enter__ `方法。`with `语句运行结束后，会在上下文管理器对象上调用 `__exit__ `方法，以此扮演`finally`子句的角色。执行`with`后面的表达式得到的结果是上下文管理器对象，不过，把值绑定到目标变量上是在上下文管理器对象上调用` __enter__ `方法的结果。

```
with expression [as var]:
	statements
```

`expression`必须返回一个对象，该对象必须支持环境管理协议。其工作方式为：计算`expression`表达式的值，得到环境管理器对象。环境管理器对象必须有`.__enter__(self)`方法和`.__exit__(self, exc_type, exc_value, traceback)`方法；调用环境管理器对象的`.__enter__(self)`方法。如果有`as`子句，`.__enter__(self)`方法返回值赋值给`as`子句中的变量`var`；如果没有`as`子句，则`.__enter__(self)`方法返回值直接丢弃；执行`statements`代码块；如果`statements`代码块抛出异常，则`.__exit__(self, exc_type, exc_value, traceback)`方法自动被调用；若`.__exit__()`方法返回值为`False`，则重新抛出异常到`with`语句之外；若`.__exit__()`方法返回值为`True`，则异常终止于此，并不会抛出`with`语句之外；如果`statements`代码块未抛出异常，则`.__exit__(self, exc_type, exc_value, traceback)`方法自动被调用，调用参数为：`.__exit__(self,None,None,None)`。`with`语句可以指定多个环境管理器，以逗号分隔。根据定义的顺序这些环境管理器对象的`.__enter__(self)`方法顺序调用，`.__exit__(self, exc_type, exc_value, traceback)`方法逆序调用

`@contextmanager `装饰器能减少创建上下文管理器的样板代码量，因为不用编写一个完整的类，定义 `__enter__ `和 `__exit__ `方法，而只需实现有一个`yield`语句的生成器，生成想让 `__enter__ `方法返回的值。
在使用` @contextmanager `装饰的生成器中，`yield `语句的作用是把函数的定义体分成两部分：`yield `语句前面的所有代码在`with`块开始时即解释器调用 `__enter__ `方法时执行， `yield`语句后面的代码在`with`块结束时即调用 `__exit__ `方法时执行。其实，`contextlib.contextmanager `装饰器会把函数包装成实现 `__enter__ `和
`__exit__ `方法的类。这个类的 `__enter__ `方法有如下作用。调用生成器函数，保存生成器对象。调用 `next(gen)`，执行到`yield`关键字所在的位置。返回`next(gen)`产出的值，以便把产出的值绑定到`with/as`语句中的目标变量上。with 块终止时，`__exit__ `方法会做以下几件事。检查有没有把异常传给`exc_type`；如果有，调用`gen.throw(exception)`，在生成器函数定义体中包含`yield`关键字的那一行抛出异常。否则，调用 `next(gen)`，继续执行生成器函数定义体中`yield`语句之后的代码`。