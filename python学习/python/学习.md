##### 描述符对象

通常情况下，我们在访问类或者实例对象的时候，会牵扯到一些属性访问的魔法方法，主要包括：

① `__getattr__(self, name)`: 访问不存在的属性时调用

② `__getattribute__(self, name)`：访问存在的属性时调用（先调用该方法，查看是否存在该属性，若不存在，接着去调用①）

③ `__setattr__(self, name, value)`：设置实例对象的一个新的属性时调用

④ `__delattr__(self, name)`：删除一个实例对象的属性时调用

 实例对象属性寻找的顺序如下：

① 首先访问`__getattribute__() `魔法方法（隐含默认调用，无论何种情况，均会调用此方法）

② 去实例对象t中查找是否具备该属性：` t.__dict__ `中查找，每个类和实例对象都有一个`__dict__`的属性

③ 若在`t.__dict__ `中找不到对应的属性， 则去该实例的类中寻找，即`t.__class__.__dict__`

④ 若在实例的类中也招不到该属性，则去父类中寻找，即`t.__class__.__bases__.__dict__`中寻找

⑤ 若以上均无法找到，则会调用`__getattr__ `方法，执行内部的命令（若未重载`__getattr__`方法，则直接报错：AttributeError)

以上几个流程，即完成了属性的寻找。

因为，一旦重载了`__getattribute__() `方法，如果找不到属性，则必须要手动加入第④步，否则无法进入到 第⑤步 (`__getattr__`)的。

属性查询优先级

① `__getattribute__()`， 无条件调用

② 数据描述符：由 ① 触发调用 （若人为的重载了该`__getattribute__() `方法，可能会调职无法调用描述符）；实例对象的字典（若与描述符对象同名，会被覆盖哦）；类的字典；非数据描述符；父类的字典

⑦` __getattr__() `方法

对象属性的访问顺序：实例属性；类属性；父类属性；`__getattr__()`方法

魔法方法：`__get__(), __set__(), __delete__()`

 　方法的原型为：

　　① `__get__(self, instance, owner)`

　　② `__set__(self, instance, value)`

　　③ `__del__(self, instance)`

① self: Desc的实例对象，其实就是TestDesc的属性x

② instance: TestDesc的实例对象，其实就是t

③ owner: 即谁拥有这些东西，当然是 TestDesc这个类，它是最高统治者，其他的一些都是包含在它的内部或者由它生出来的

当Python解释器发现实例对象的字典中，有与描述符同名的属性时，描述符优先，会覆盖掉实例属性。一个类，如果只定义了` __get__() `方法，而没有定义`__set__(), __delete__()`方法，则认为是非数据描述符； 反之，则成为数据描述符

```python
#staticmethod 的效果是让 C.f 与 c.f 都返回函数，等价于 object.__getattribute__(c, "f") 或 object.__getattribute__(C, "f")
class staticmethod(object):
    def __init__(self, f):
        self.f = f

    def __get__(self, obj, objtype=None):
        return self.f
#classmethod 则是要让 C.f和 c.f 都返回方法，并且传递隐式参数 cls
class classmethod(object):
    def __init__(self, f):
        self.f = f

    def __get__(self, obj, klass=None):
        if klass is None:
            klass = type(obj)
        def newfunc(*args):
            return self.f(klass, *args)
        return newfunc
import types
class classmethod(object):
    def __init__(self, f):
        self.f = f
    def __get__(self, obj, klass=None):
        if klass is None:
            klass = type(obj)
        return types.MethodType(self.f, klass)
```





Python的警告系统考虑到了这一切:

它将警告看作一个单独的输出类型 , 这样我们就不会将它与异常或者程序的打印文本相混淆。 
它允许我们指明我们正在发送给用户哪种警告，
它可以让用户指示如何处理不同类型的警告，让一些引发严重错误，其他的在屏幕上显示它们的信息，还有一些始终被忽略，
它可以让程序员开发它们自己的、新的警告类型。

最简单的过滤器是“warnings.simplefilter”，而调用它的最简单方法是使用单个字符串参数。这个参数告诉警告系统，如果它遇到一个警告，该怎么做:

“默认”——在警告第一次出现时显示它
“错误”——将警告转换成一个异常
“忽略”——忽略警告
“总是”——总是显示警告，即使它以前被显示过
“模块”——每个模块显示一次警告
“一次”——在整个程序中只显示一次警告
one of "error", "ignore", "always", "default", "module",or "once"

##### 字符串

转义的语法：一个`\`+单个字符，组合后单个字符失去原来字面意义，会被赋予一个新的功能。常见的转义字符：`\n` 完成换行，`\t` tab 空格等。

###### 字符串格式化

```python
print("i am {0},age {1}".format("tom",18))
tom = 'tom'
age = 18
print(f'i am {tom}, age {age}')
print("{:.2f}".format(3.1415926)) # 1 保留小数点后两位
print("{:+.2f}".format(-1)) #带符号保留小数点后两位
print("{:.0f}".format(2.718)) # 不带小数位
print("{:0>3d}".format(5)) # 整数补零，填充左边, 宽度为3
print("{:,}".format(10241024)) # 以逗号分隔的数字格式
print("{:.2%}".format(0.718)) # 百分比格式
print("{:.2e}".format(10241024)) # 指数记法
```

