通常情况下，我们在访问类或者实例对象的时候，会牵扯到一些属性访问的魔法方法，主要包括：

① __getattr__(self, name): 访问不存在的属性时调用

② __getattribute__(self, name)：访问存在的属性时调用（先调用该方法，查看是否存在该属性，若不存在，接着去调用①）

③ __setattr__(self, name, value)：设置实例对象的一个新的属性时调用

④ __delattr__(self, name)：删除一个实例对象的属性时调用

 

 实例对象属性寻找的顺序如下：

① 首先访问 __getattribute__() 魔法方法（隐含默认调用，无论何种情况，均会调用此方法）

② 去实例对象t中查找是否具备该属性： t.__dict__ 中查找，每个类和实例对象都有一个 __dict__ 的属性

③ 若在 t.__dict__ 中找不到对应的属性， 则去该实例的类中寻找，即 t.__class__.__dict__

④ 若在实例的类中也招不到该属性，则去父类中寻找，即 t.__class__.__bases__.__dict__中寻找

⑤ 若以上均无法找到，则会调用 __getattr__ 方法，执行内部的命令（若未重载 __getattr__ 方法，则直接报错：AttributeError)

以上几个流程，即完成了属性的寻找。

因为，一旦重载了 __getattribute__() 方法，如果找不到属性，则必须要手动加入第④步，否则无法进入到 第⑤步 (__getattr__)的。

对象属性的访问顺序：

①.实例属性

②.类属性

③.父类属性

④.__getattr__()方法

魔法方法：__get__(), __set__(), __delete__()

 　方法的原型为：

　　① __get__(self, instance, owner)

　　② __set__(self, instance, value)

　　③ __del__(self, instance)

① self: Desc的实例对象，其实就是TestDesc的属性x

　　② instance: TestDesc的实例对象，其实就是t

　　③ owner: 即谁拥有这些东西，当然是 TestDesc这个类，它是最高统治者，其他的一些都是包含在它的内部或者由它生出来的

当Python解释器发现实例对象的字典中，有与描述符同名的属性时，描述符优先，会覆盖掉实例属性。

一个类，如果只定义了 __get__() 方法，而没有定义 __set__(), __delete__() 方法，则认为是非数据描述符； 反之，则成为数据描述符

属性查询优先级

　　　　① __getattribute__()， 无条件调用

　　　　② 数据描述符：由 ① 触发调用 （若人为的重载了该 __getattribute__() 方法，可能会调职无法调用描述符）

　　　　③ 实例对象的字典（若与描述符对象同名，会被覆盖哦）

　　　　④ 类的字典

　　　　⑤ 非数据描述符

　　　　⑥ 父类的字典

　　　　⑦ __getattr__() 方法