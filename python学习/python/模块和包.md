在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色，所以我们通常会将一个颜色表示为一个`RGB`值或`RGBA`值，其中的A表示Alpha通道，透明度。

| 名称  |        RGBA值        |  名称  |       RGBA值       |
| :---: | :------------------: | :----: | :----------------: |
| White | (255, 255, 255, 255) |  Red   |  (255, 0, 0, 255)  |
| Green |   (0, 255, 0, 255)   |  Blue  |  (0, 0, 255, 255)  |
| Gray  | (128, 128, 128, 255) | Yellow | (255, 255, 0, 255) |
| Black |    (0, 0, 0, 255)    | Purple | (128, 0, 128, 255) |

像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。

#### 包和模块

| 名称         | 定义                                                         |
| ------------ | ------------------------------------------------------------ |
| 包`package`  | 一个文件夹，它里面会有一个`__init__.py`，还有其他`.py`文件。`__init__.py`会使得普通的文件夹变为包. 实际上，`__init__.py`也是一个模块，其名称正是包的名字。 |
| 模块`module` | 我们自己定义的`.py`文件，一个模块就是一个`py`文件，里面封装了一个功能模块，可能有函数、类、变量等。 |
| `namespace`  | 一个从名字到对象的映射。 大部分命名空间当前都由 Python 字典实现。 |



在一个模块内部，模块名可以通过全局变量 `__name__` 的值获得。每个模块都有它自己的私有符号表，该表用作模块中定义的所有函数的全局符号表。因此，模块的作者可以在模块内使用全局变量，而不必担心与用户的全局变量发生意外冲突。当文件是以顶层程序文件执行时，该模块的`__name__`属性会设为字符串`"__main__"`。若文件被导入，则`__name__`属性就成为文件名去掉后缀的名字。

当一个名为 `spam` 的模块被导入的时候，解释器首先寻找具有该名称的内置模块。如果没有找到，然后解释器从`sys.path`变量给出的目录列表里寻找名为 `spam.py` 的文件。`sys.path` 初始有这些目录地址: 包含输入脚本的目录或者未指定文件时的当前目录。`PYTHONPATH`。取决于安装的默认设置当一个名为 `spam` 的模块被导入的时候，解释器首先寻找具有该名称的内置模块。如果没有找到，然后解释器从`sys.path` 变量给出的目录列表里寻找名为 `spam.py` 的文件。

##### 导入

`import`时，也可以指定目录。目录称为包，这类的导入称为包导入。包导入是将计算机上的目录变成另一个Python命名空间，它的属性对应于目录中包含的子目录和模块文件

```python
import dir1.dir2.modname #包导入的语法
from dir1.dir2.modname import x
```

包导入语句的路径中，每个目录内部必须要有`__init__.py`这个文件。否则包导入会失败。`__init__.py`就像普通模块文件，它可以为空的。Python首次导入某个目录时，会自动执行该目录下`__init__.py`文件的所有程序代码。`import dir1.dir2.modname`包导入后，每个目录名都成为模块对象（模块对象的命名空间由该目录下的`__init__.py`中所有的全局变量定义（包含显式定义和隐式定义）决定）。`__init__.py`中的全局变量称为对应目录包的属性。任何已导入的目录包也可以用`reload`重新加载，来强制该目录包重新加载

```python
#包相对导入
from . import modname1 #modname1与本模块在同一包中（即与本文件在同一目录下）
from .modname1 import name #modname1与本模块在同一包中（即与本文件在同一目录下）
from .. import modname2 #modname2在本模块的父目录中（即在本文件上层）
#Python3中，没有点号的导入均为绝对导入。`import`总是优先在包外查找模块  
```

模块导入另一个模块后，可以直接使用被导模块定义的全局变量名。

当文件`import`时，会进行编译产生字节码文件`.pyc`，因此只有被导入文件才会在机器上留下`.pyc`文件。顶层文件的字节码在内部使用后就丢弃了，并未保留下来。

`from`与`import`都是隐性赋值语句；`from`与`import`对本模块的命名空间影响不同：`from`会在命名空间中引入`from import`的变量名而不会引入模块名，`import`会在命名空间中引入模块名；`from`、`import`与`def`一样是可执行语句，而不是编译器声明。 对象并没有赋值给变量名：`import module1`:`module1`既是模块名，也是一个变量名；`from module1 import func`：`module1`仅仅是模块名，而不是变量名；模块的命名空间可以通过属性`.__dict__`或者`dir(modname)`来获取。



Python模块会默认导出其模块文件顶层所赋值的所有变量名，不存在私有变量名。

下划线开始的变量名`_x`：`from *`导入该模块时，这类变量名不会被复制出去，模块文件顶层的变量名列表`__all__`：它是一个变量名的字符串列表。`from *`语句只会把列在`__all__`列表中的这些变量名复制出来。  

Python会首先查找模块内的`__all__`列表；否该列表未定义，则`from *`会复制那些非`_`开头的所有变量名所有这些隐藏变量名的方法都可以通过模块的属性直接绕开。



##### 重载

重载函数`reload()`：它会强制已加载的模块代码重新载入并重新执行，`reload`函数可以修改程序的一部分，而无需停止整个程序，`reload`函数只能用于Python编写的模块，而无法用于其它语言编写的扩展模块。`reload()`与`import`和`from`的差异：`reload`是Python内置函数，返回值为模块对象，`import`与`from`是语句，传递给`reload`是已经存在的模块对象，而不是一个变量名，`reload`在位于`imp`标准库模块中，必须首先导入才可用。

`reload`工作细节：适用于在测试代码过程中，对代码进行了修改。使用python编写代码，用`jupyter`进行调试时，发现错误进行修改，可以使用`reload`。`reload`并不会删除并重建模块对象，它只是修改模块对象。即原来模块的每个属性对象内存空间还在，所有旧的引用指向他们，新的引用指向修改后的属性对象内存空间；`reload`会在模块当前命名空间内执行模块文件的新代码；`reload`会影响所有使用`import`读取了模块的用户，用户会发现模块的属性已变；`reload`只会对以后使用`from`的代码造成影响，之前用`from`的代码并不受影响。之前的名字还可用，且引用的是旧对象。`reload(modname)`只会重载模块`modname`，而对于模块`modname`文件中`import`的模块，`reload`函数不会自动加载。要想`reload`模块`A`以及`A` `import`的所有模块，可以手工递归扫描`A`模块的`__dict__`属性，并检查每一项的`type`以找到所有`import`的模块然后`reload`这些模块 

#### 文件操作

