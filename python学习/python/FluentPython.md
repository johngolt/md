### 数据结构

Python的多态是`x.method`的方法运行时，`method`的意义取决于`x`的类型，属性总是在运行期解析

Python允许执行连续比较，且比较链可以任意长：`a<b<c`结果等同于`a<b and b<c`、`a<b>c`结果等同于`a<b and b>c`

比较操作时，Python能够自动遍历嵌套的对象，从左到右递归比较，要多深有多深。过充中首次发现的差异将决定比较的结果。 

变量名由：下划线或字母开头，后面接任意字母、数字、下划线，以单下划线开头的变量名不会被`from module import *`语句导入，如变量名`_x`，前后双下划线的变量名是系统预定义的，对解析器有着特殊的意义，如变量名`__x__`，仅前面有双下划线的变量名视为类的本地变量，如变量名`__x`

扩展的序列解包赋值：收集右侧值序列中未赋值的项为一个列表，将该列表赋值给带星号`*`的变量

左边的变量名序列长度不需要与值序列的长度相等，其中只能有一个变量名带星号`*`
* 若带星号`*`变量名只匹配一项，则也是产生一个列表，列表中只有一个元素，如`a,*b="12"`，`b`为`[2]`
* 若带星号`*`变量名没有匹配项，则也是产生空列表，如`a,*b="1"`，`b`为`[]`

* 带星号`*`的变量名可以出现在变量名序列中的任何位置如`*a,b="1234"`，`a`为`[1,2,3]`
* 匹配过程优先考虑不带星号的变量名，剩下的才匹配带星号的变量名
* 以下情况会引发错误：
  * 左侧变量名序列有两个星号，如`*a,*b="abcd"`
  * 左侧变量名序列无星号但是左右长度不匹配，如`a,b="abcd"`
  * 左侧变量名序列星号的名称不在序列中，如`*a='abcd'`

#### 序列构成的数组

容器序列: `list、tuple`和 `collections.deque `这些序列能存放不同类型的数据。扁平序列: `str、bytes、bytearray、memoryview` 和` array.array`，这类序列只能容纳一种类型。容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。换句话说，扁平序列其实是一段连续的内存空间。由此可见扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型。序列类型还能按照能否被修改来分类。可变序列: `list、bytearray、array.array、collections.deque` 和 `memoryview`。不可变序列: `tuple、str `和 `bytes`。

![](../../picture/1/33.png)

列表推导、生成器表达式，以及同它们很相似的集合推导和字典推导，在 `Python3`中都有了自己的局部作用域，就像函数似的。表达式内部的变量和赋值只在局部起作用，表达式的上下文里的同名变量还可以被正常引用，局部变量并不会影响到它们。

###### 数组

如果我们需要一个只包含数字的列表，那么`array.array`比 `list`更高效。数组支持所有跟可变序列有关的操作。另外，数组还提供从文件读取和存入文件的更快的方法，如`.frombytes`和`.tofile`。Python数组跟C语言数组一样精简。创建数组需要一个类型码，这个类型码用来表示在底层的C语言应该存放怎样的数据类型。而且Python不会允许你在数组里存放除指定类型之外的数据。

| 函数               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| `s.fromfile(f, n)` | 将二进制文件f内含有机器值读出来添加到尾部，最多添加 n 项     |
| `s.fromlist(l)`    | 将列表里的元素添加到尾部，如果其中任何一个元素导致了 `TypeError`异常，那么所有的添加都会取消 |
| `s.tobytes()`      | 把所有元素的机器值用 bytes 对象的形式返回                    |
| `s.tofile(f)`      | 把所有元素以机器值的形式写入一个文件                         |
| `s.tolist()`       | 把数组转换成列表，列表里的元素类型是数字对象                 |
| `s.typecode`       | 返回只有一个字符的字符串，代表数组元素在 C 语言中的类型      |

#### 字典和集合

从`UserDict`而不是从`dict`继承的主要原因是，后者有时会在某些方法的实现上走一些捷径，导致我们不得不在它的子类中重写这些方法，但是`UserDict`就不会带来这些问题。`UserDict `并不是 `dict `的子类，但是 `UserDict `有一个叫作 data 的属性，是 `dict `的实例，这个属性实际上是 `UserDict `最终存储数据的地方。

![](../../picture/1/35.png)

标准库里的所有映射类型都是利用` dict `来实现的，因此它们有个共同的限制，即只有可散列的数据类型才能用作这些映射里的键。如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现` __hash__() `方法。另外可散列对象还要有`__qe__() `方法，这样才能跟其他键做比较。如果两个可散列对象是相等的，那么它们的散列值一定是一样的。一般来讲用户自定义的类型的对象都是可散列的，散列值就是它们的` id() `函数的返回值，所以所有这些对象在比较的时候都是不相等的。如果一个对象实现了 `__eq__ `方法，并且在方法中用到了这个对象的内部状态的话，那么只有当所有这些内部状态都是不可变的情况下，这个对象才是可散列的。`setdefault`用来处理键值缺失情况。

##### 映射的弹性键查询

有时候为了方便起见，就算某个键在映射里不存在，我们也希望在通过这个键读取值的时候能得到一个默认值。有途径能帮我们达到这个目的，一个是通过` defaultdict `这个类型而不是普通的` dict`，另一个是给自己定义一个` dict `的子类，然后在子类中实现`__missing__ `方法。在实例化一个 `defaultdict `的时候，需要给构造方法提供一个可调用对象，这个可调用对象会在 `__getitem__ `碰到找不到的键的时候被调用，让 `__getitem__ `返回某种默认值。`defaultdict `里的` default_factory `只会在 `__getitem__ `里被调用，在其他的方法里完全不会发挥作用。所有的映射类型在处理找不到的键的时候，都会牵扯到` __missing__ `方法。虽然基类 `dict `并没有定义这个方法，但是 `dict `是知道有这么个东西存在的。也就是说，如果有一个类继承了` dict`，然后这个继承类提供了`__missing__ `方法，那么在 `__getitem__ `碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个 `KeyError `异常。`__missing__ `方法只会被 `__getitem__ `调用。提供 `__missing__ `方法对 `get `或者 `__contains__`这些方法的使用没有影响。

##### 集合

![](../picture/1/41.png)

散列表其实是一个稀疏数组：总是有空白元素的数组称为稀疏数组。在一般的数据结构教材中，散列表里的单元通常叫作表元。在` dict `的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。因为 Python 会设法保证大概还有三分之一的表元是空的，所以在快要达到这个阈值的时候，原有的散列表会被复制到一个更大的空间里面。为了获取` my_dict[search_key] `背后的值，Python 首先会调用` hash(search_key)`来计算` search_key `的散列值，把这个值最低的几位数字当作偏移量，在散列表里查找表元。若找到的表元是空的，则抛出`KeyError `异常。若不是空的，则表元里会有一对` found_key:found_value`。这时候 Python 会检验` search_key == found_key `是否为真，如果它们相等的话，就会返回` found_value`。如果 `search_key `和 `found_key `不匹配的话，这种情况称为散列冲突。发生这种情况是因为，散列表所做的其实是把随机的元素映射到只有几位的数字上，而散列表本身的索引又只依赖于这个数字的一部分。为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊的方法处理一下，把新得到的数字再当作索引来寻找表元。若这次找到的表元是空的，则同样抛出 `KeyError`；若非空，或者键匹配，则返回这个值；或者又发现了散列冲突，则重复以上的步骤。

![](../picture/1/42.png)

#### 文本和字节序列

占位符有多种：  `%s`：字符串； `%r`：也是字符串，但用`repr()`得到的而不是`str()`；  `%c`：字符； `%d`：十进制整数； `%i`：整数； `%e`：浮点指数；  `%f`： 浮点十进制；`%%`：百分号 `%`， `%g`：自动转成浮点`%e`或者`%f`  

转换通用目标结构为：`%[(key_name)][flags][width][.precision]type`

* `key_name`：用于从右边字典中取对应键的值，如：`"%(n)%d %(x)%s" %{"n":3,"x":"apples"}` 
* `flags`：如果为`-`则左对齐；如果为`+`则为正负号；如果为`0`：则补零
* `width`： 指定位宽，至少为`width`字符宽度
* `precision`：指定小数点后几位
* `type`为类型，如`d`,`r`,`f`,`e`等  

格式化字符串除了使用字符串格式化表达式之外，还可以通过字符串的`.format()`方法达到同样的效果。`.format()`方法支持位置参数、关键字参数、以及二者的混合。

* 位置参数： `"{0},{1},{2}".format('abc','def','ghi')`
* 关键字参数：`"{k1},{k2},{k3}".format(k1='abc',k2='def',k3='ghi')`
* 混合使用：`"{0},{1},{k}".format('abc','def',k='ghi')`  

* 格式化字符串中可以指定对象的属性、字典键、序列的索引：指定字典的键：`"{0[a]}".format({'a':'value'})`，指定对象的属性：`"{0.platform}".format(sys)`，也可以用关键字参数：`"{obj.platform}".format(obj=sys)`；指定序列的索引：`"{0[2]}".format("abcd")` ，这里只能进行正索引值，且不能分片 
* 通用目标结构为： `{fieldname!conversionflag:formatspec}`
  * `fieldname`为位置数字 0,1,2,或者为关键字，它后面可选地跟随
  * `conversionflag`为转换标记，没用过，所以不关键。
  * `formatspec`为格式，其结构为：`[[fill] align] [sign] [#] [0] [width] [.precision] [type]`：`fill`一般与`align`为`=`时配合；`align`为对齐：`<`：左对齐；`>`：右对齐；`=`：必须指定`fill`，此时用这个字符填充；`^`：居中对齐；`sign`：为正负号标记；`0`：补0；`width`：位宽；`.precision`：精度；`type`：为类型，如`d`,`r`,`f`,`e`等，但与格式化字符串表达式相比，多了`b`

##### 字符问题

每一个字符对应一个标识或码位，码位时数值，数值与字符一一对应，然后通过编码将数值编码成不同的字节序列，解码就是将字节序列解读成数值，然后通过数值找到对应的字符。不同的编码方式就是不同的函数将字节序列映射成码位。通过一个字典将字符和数字进行一一映射，然后通过字节来表示不同的数字，这样就建立了字节和字符之间的一一对应关系。字符的最佳定义是Unicode字符。**字符的标识**即码位，是`0~1114111`的数字。字符的具体表述取决于所用的编码。编码是在码位和字节序列之间转换时使用的算法。把码位转换成字节序列的过程是编码；把字节序列转换成码位的过程是解码。把文本转换成字节序列时，如果目标编码中没有定义某个字符，那就会抛出` UnicodeEncodeError `异常，除非把` errors `参数传给编码方法或函数，对错误进行特殊处理。不是每一个字节都包含有效的ASCII字符，也不是每一个字符序列都是有效的` UTF-8 `或`UTF-16`。因此，把二进制序列转换成文本时，如果假设是这两个编码中的一个，遇到无法转换的字节序列时会抛出` UnicodeDecodeError`。另一方面，很多陈旧的 8 位编码如` 'cp1252'` 能解码任何字节序列流而不抛出错误。

有三种字符串相关类型：`str`类型表示`Unicode`文本，为不可变的字符序列，称为字符串；`bytes`表示二进制数据，称为字节串。`bytes`对象其实是小整数的一个序列，每个整数的范围在0～255之间，`list(bytes_obj)`返回一个整数列表而不是字符列表；`bytearray`是一种可变的`bytes`类型，称为可变字节串。`bytearray`是`bytes`的一个变体，它是可变的且支持原地修改。它支持`str`与`bytes`的常见操作，以及与列表相同的一些原地修改操作。字符串的`.encode(encoding)`方法和`bytes(a_string,encoding)`函数将一个字符串实例转换为它原生`bytes`形式；字符串的`str(a_bytes,encoding)`函数和`.decode(encoding)`方法将一个`bytes`实例解码成字符串形式。`bytearray`实例的构造：`bytearray('abc',encoding='ascii')`：通过构造函数传入字符串和编码构造; `bytearray(b'abc')`：通过`bytes`常量构造

##### 处理文本文件

处理文本的最佳实践是“Unicode 三明治”。 意思是，要尽早把输入的字节序列解码成字符串。这种三明治中的“肉片”是程序的业务逻辑，在这里只能处理字符串对象。在其他处理过程中，一定不能编码或解码。对输出来说，则要尽量晚地把字符串编码成字节序列。

![](../picture/1/30.png)

如果打开文件时没有指定 encoding 参数，默认值由`locale.getpreferredencoding()` 提供。如果打开文件时没有指定` encoding `参数，默认值由`locale.getpreferredencoding() `提供。当一个文件以文本模式打开时，读取其数据会自动将其内容解码，并返回一个字符串；当一个文件以文本模式写打开时，写入一个字符串会在将该字符串写入文件之前自动编码它。当一个文件以二进制模式打开时，读取其数据直接返回其原生内容而并不以任何方式解码，也不做任何方式修改，直接作为`bytes`实例返回；写入会接受一个`bytes`实例或者一个`bytearray`实例，并且不加修改地写入到文件

### 把函数视作对象

Python中，函数也是一种对象类型，Python运行到`def`语句时，它将会生成一个新的函数对象，并将该函数对象赋值给这个函数名。函数名成了这个函数对象的引用，`lambda`表达式创建一个函数对象并返回它，但是它并没有绑定一个名字即它是匿名的没有函数名，`return`语句将一个结果对象发送给调用者，`yield`语句使得函数成为一个生成函数，与C语言不同，Python函数在程序运行之前不需要全部定义。`def`在它定义的地方时才评估，而`def`的之内的代码在函数调用的时候才求值，函数主体内的代码直到函数被调用时才运行。函数内的变量名在函数实际执行之前都不会解析。定义的函数时`function`类的实例。调用函数相当于调用实例的`__call__`方法。

当在python中以`x+y`计算两个数的和时，x和y这两个名称一定要与先前作为值的对象相关联；如果没有找到相关定义，会抛出一个`NameError`异常。确定与标识符相关联的值的过程称为名称解析。python中每一个定义域使用了一个抽象名称，称为命名空间。命名空间管理当前在给定作用域内定义的所有标识符。python中实现命名空间使用自己的字典将每一个标识符字符串映射到其相关的值。python提供几种方法来检查一个给定的命名空间。函数`dir`报告给定命名空间中的标识符的名称，而函数`vars`返回完整的字典。默认情况下，调用`dir`和`vars`报告的是执行过程中本地封闭的命名空间。在命名中指示标识符时，python会在名称解析过程中搜索一系列的命名空间。首先，搜索的是所给名字的本地命名空间，若没有找到，则搜索外一层的命名空间，然后以此类推。

变量可以在3个不同的地方定义，对应三种不同的作用域：`def`内赋值定义的变量：作用域为本函数，这里的赋值包括显式`=`赋值和隐式赋值。隐式赋值包括，`import`语句隐式赋值，`def`函数定义来隐式赋值，形参匹配来隐式赋值，嵌套的`def`中赋值定义的变量：对于父函数来说，该变量不是本地的，`def`之外赋值，作用域为整个文件全局的。作用域法则：每个模块文件就是一个全局作用域。从外面看，模块的全局变量就成为该模块对象的属性；从内部看，模块的全局变量就是普通的、作用域为全局的变量，全局作用域的范围仅限于变量所在的单个文件，每次调用函数，都创建一个新的局部作用域，默认情况下，所有函数定义内部的变量都是局部变量，`global`语句声明会将变量名作用域提升至全局，`nonlocal`语句声明会将变量名作用域提升至外层的`def`。变量名查找规则：`LGBE`：首先查找本地作用域`L`，接着查找上一层`def`或`lambda`的本地作用域`E`，接着查找全局作用域`G`，最后查找内置作用域`B`，如果均未找到变量名则报错。 

```python
#嵌套作用域中的变量在嵌套的函数调用时才进行查找，而不是定义时。 
def func():
	acts=[]
	for i in range(5):
		acts.append(lambda x:i**x) #添加匿名函数对象
	return acts
acts=func();acts[0](2) #调用时才开始查找i,此时i最后被记住的值是4
```

参数传递的性质：参数的传递是通过自动将对象赋值给本地变量名来实现的，在函数内部的参数名赋值不会影响到实参对象，只是将变量名重新引用到另一个对象，若实参对象为可变对象，则在函数内原地修改参数对象会影响所有的指向该实参对象的引用。

默认情况下，参数匹配是通过其位置进行匹配的，从左到右一一匹配。必须精确传递和函数签名中参数名一样多的实参。关键字参数：允许通过变量名进行匹配，而不是通过位置。其中关键字顺序可以任意；默认参数：函数定义时，可以为参数设定默认值，这样允许调用时传递较少的参数，默认实参后面不能跟随非默认实参。如果出现这种情况则报语法错误；可变参数：函数能用特定的参数（以`*`开头），收集任意多的额外位置参数，将收集到的位置相关的参数到一个新元组中。  函数能用特定的参数（以`**`开头），收集任意多的额外关键字参数，将收集关键字相关的参数到一个新字典中；`keyword-only`参数：它是一种命名参数，出现在`*`参数之后，在`**`参数之前。所有的`keyword-only`参数必须使用关键字语法传递。   

可变参数解包：调用者可以用`*`语法将实参（如元组、列表、`set`）打散，形成位置参数，调用者可以用`**`语法将字典实参打散，形成关键字参数    

函数定义时的参数类型顺序：

```python
def func(a,b,c='c',*d,e,f='f',**g):
	pass
	func('a','b',e='e',*seq,**dic)
#seq是一个序列，它解包之后优先覆盖c，剩下的再收集成元组传给d，dic是一个字典，它解包之后优先考虑e,f，剩下的在收集成字典传递给g，e='e'这个关键字实参也可以位于'b'之后的任何位置，关键字实参必须位于位置实参之后 
```

编程语言理论家把一等对象定义为满足下述条件的程序实体：在运行时创建；能赋值给变量或数据结构中的元素；能作为参数传给函数；能作为函数的返回结果。除了用户定义的函数，调用运算符，即`()`，还可以应用到其他对象上。如果想判断对象能否调用，可以使用内置的 callable() 函数。用户定义的函数、内置函数、内置方法、方法：在类的定义体中定义的函数；**类**：调用类时会运行类的` __new__ `方法创建一个实例，然后运行` __init__ `方法，初始化实例，最后把实例返回给调用方。因为 Python 没有`new`运算符，所以调用类相当于调用函数；**类的实例**：如果类定义了` __call__ `方法，那么它的实例可以作为函数调用；**生成器函数**：使用 yield 关键字的函数或方法。调用生成器函数返回的是生成器对象。

##### 函数内省

函数专有而用户定义的一般对象没有的属性。

| 名称             | 类型             | 说明                                 |
| ---------------- | ---------------- | ------------------------------------ |
| `__annotation__` | `dict`           | 参数和返回值的注解                   |
| `__call__`       | `method-wrapper` | 实现`()`运算符；即可调用对象协议     |
| `__closure__`    | `tuple`          | 函数闭包，即自由变量的绑定           |
| `__code__`       | `code`           | 编译成字节码的函数元数据和函数定义体 |
| `__defaults__`   | `tuple`          | 形式参数的默认值                     |
| `__get__`        | `method-wrapper` | 实现只读描述符协议                   |
| `__globals__`    | `dict`           | 函数所在模块中的全局变量             |
| `__kwdefaults__` | `dict`           | 仅限关键字形式参数的默认值           |
| `__name__`       | `str`            | 函数名称                             |
| `__qualname__`   | `str`            | 函数的限定名称                       |

#### 函数装饰器和闭包

装饰器是用于包装其他可调用对象的一个可调用对象，它是一个可调用对象，其调用参数为另一个可调用对象，它返回一个可调用对象：一个函数对象是可调用对象。一个类对象是可调用对象，对它调用的结果就是返回类的实例。实现了`.__call__()`方法的类，其实例对象是可调用对象，对它调用的结果就是调用`.__call__()`方法。装饰器有两种使用形式：函数的装饰器：在函数对象定义的时候使用装饰器，用于管理该函数对象；类的装饰器：在类定义的时候使用该装饰器，用于管理该类以及类的实例

函数的装饰器：用于管理函数。函数的装饰器声明为：

```python
@decorator
def func(*pargs,**kwargs):
	pass
func=decorator(func) # 等价于
```

执行了装饰器的`def`之后，函数名指向的不再是原来的函数对象，而是：一个可调用对象， 当`decorator`是个函数时由`decorator(func)`函数返回的；`decorator`类的实例，当`decorator`是个类时，由`decorator(func)`构造方法返回

类的装饰器：用于管理类。类的装饰器声明为：

```python
@decorator
class A:
	pass
A=decorator(A)
```

类的装饰器并不是拦截创建实例的函数调用，而是返回一个不同的可调用对象，执行了装饰器的`class`之后，类名指向的不再是原来的类对象，而是：一个可调用对象， 当`decorator`是个函数时由`decorator(func)`函数返回的；`decorator`类的实例，当`decorator`是个类时，由`decorator(func)`构造方法返回

```python
def decorator(func): #定义了一个叫decorator的装饰器
	#某些处理
	return func #返回可调用对象
class decorator: #也可以用类来实现装饰器
	def __init__(self,func):
		self.func=func
	def __call__(self,*args,**kwargs):
		return self.func
def decorator(func): #定义了一个叫decorator的装饰器
	def wrapper(*args):
		#使用func或其他的一些工作
	return wrapper #返回可调用对象
```

```python
@decoratorA
@decoratorB
@decoratorC
def func():
	pass
f=A(B(C(f))) #装饰器的嵌套
```

装饰器可以携带参数。函数定义的装饰器带参数：它其实是一个嵌套函数。外层函数的参数为装饰器参数，返回一个函数。内层函数的参数为`func`，返回一个可调用参数，<font color='red'>内层函数才是真正的装饰器</font>

```python
def decorator(*args,**kwargs): 
	print("this is decorator1:",args,kwargs)
	def actualDecorator(func): # 这才是真实的装饰器
		...
		return func
	return actualDecorator
```

类定义的装饰器带参数：它其实是一个嵌套类。外层类的初始化函数的参数为装饰器参数，外层类的`__call__`函数的参数为`func`，返回值为一个类的实例；内层类的初始化函数参数为`func`；内层类的`__call__`函数使用`func`，<font color='red'>内层类才是真正的装饰器</font>

```python
class decorator2:
	class ActualDecorator: #这才是真实的装饰器
		def __init__(self,func):
			...
			self.func=func#记住func
		def __call__(self,*args,**kwargs):
			...
			return self.func(*args,**kwargs) #使用func
	def __init__(self,*args,**kwargs):
		...
	def __call__(self,func):
		...
		return decorator2.ActualDecorator(func) 
```

总结：不带参数的装饰器`decorator`装饰一个名字`F``@decorator`：则执行的是：`F=decorator(F)`，直接使用`F`；带参数的装饰器`decorator`装饰一个名字`F``@decorator(args)`：则执行的是：`F=decorator(args)(F)`，间接使用`F` 。装饰器在加载模块时立即执行：它们在被装饰的函数定义之后立即运行。这通常是在导入时，函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。

![](../picture/1/31.png)

闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。`nonlocal `声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为` nonlocal `声明的变量赋予新值，闭包中保存的绑定会更新。解析源码中的装饰器时，`Python`把被装饰的函数作为第一个参数传给装饰器函数。那怎么让装饰器接受其他参数呢？答案是：创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。

### 面向对象编程

Python中，类`class`与实例`instance`是两种不同的对象类型：类对象是实例对象的工厂；类对象与实例对象都有各自独立的命名空间；实例对象可自动存取类对象中的变量名；类属性为所有的实例对象提供状态和行为，它是由该类创建的所有实例对象共享的，每个实例对象都有自己的命名空间。同一个类的实例对象不一定属性都相同，每一个实例对象继承类的属性并创建了自己的命名空间，类创建的实例对象是有新的命名空间。刚开始该命名空间是空的，但它会继承创建该实例所属类对象的属性。继承的意思是，虽然实例对象的命名空间是空的。但是名字查找会自动上升到类对象的名字空间去查找，可以在`class`语句外创建类对象的新属性，通过向类对象直接赋值来实现。

类可以继承。被继承的类称为超类，继承类称为子类。类对象会继承其超类对象中定义的所有类属性名称，类对象的 `.__dict__`属性是类对象的命名空间，是一个类字典对象`mappingproxy`对象 ； 实例对象的 `.__dict__`属性是实例对象的命名空间，是一个字典； 实例对象的`.__class__`属性是它所属的类，类对象的`__bases__`属性是它超类对象的元组，类对象的`__name__`属性是类名，在子类中调用超类的方`superClass.func(obj,args)`，其中`obj`通常为`self` ，`self`使得可以使用子类的属性，在子类中重载父类方法。

若子类重新定义了超类的变量名，子类会取代并定制所继承的行为。这称为重载。在Python中，当对象通过点号运算读取属性值时就会发生继承，而且涉及了搜索属性定义树。每次使用`name.attr`时(`name`为实例对象或者类对象），Python会从底部向上搜索命名空间树。先从本对象的命名空间开始，一直搜索到第一个找到的`attr`名字就停止，命名空间树中较低位置处的定义会覆盖较高位置处的定义，继承树的搜索仅仅发生在读取属性值的时候。在写属性值时，执行的是属性的定义(当前命名空间中该名字不存在)或赋值(当前命名空间中该名字已存在)语义。

~~~mermaid
graph BT;
A(实例命名空间)-->B[类命名空间];
B-->C[超类1命名空间];
B-->D[超类2命名空间];
style A fill:#f9f,stroke:#333;
~~~

在`Python3`中所有的类都是新式类。所有的类都是从`object`内置类派生而来，`type(obj)`返回对象实例所属的类对象，`type(classname)`返回`"type"`，因为所有`class`对象都是`type`的实例，由于所有`class`均直接或者间接地派生自`object`类，因此每个实例对象都是`object`类的实例，`object`是`type`类的实例，但是同时`type`又派生自`object`。`Python3`中的类有一个`.__slots__`属性，它是一个字符串列表。这个列表限定了类的实例对象的合法属性名。如果给实例赋了一个`.__slots__`列表之外的属性名会引发异常，当有`.__slots__`列表存在时，默认会删除`.__dict__`属性，而`getattr()`，`setattr()`以及`dir()`等函数均使用`.__slots__`属性，因此仍旧可以正常工作，在继承中: 若子类继承自一个没有`.__slots__`的超类，则超类的`.__dict__`属性可用，则子类中的`.__slots__`没有意义。因为子类继承了超类的`.__dict__`属性，若子类有`.__slots__`，超类也有`.__slots__`，子类的合法属性名为父类和子类的`.__slots__`列表的并集，若超类有`.__slots__`，子类未定义`.__slots__`，则子类将会有一个`.__dict__`属性

```python
  class A:
    	def __init__(self):
        	self._x = None
    	@property #定义了一个property get函数，必选
    	def x(self): # property name 就是 get函数的函数名
        	return self._x
    	@x.setter #定义了一个property set函数，可选
    	def x(self, value):
        	self._x = value
```

总结一下，类中可以定义四种方法：

- 普通方法：方法就是类对象的一个属性，执行常规函数调用语义`classname.method(args)`
- 实例方法：传入一个实例作为方法的第一个实参。调用时可以：`obj.method(args)`:通过实例调用、`classname.method(obj,args)`：通过类调用
- `staticmethod`方法：当以实例对象调用`staticmethod`方法时，Python并不会将实例对象传入作为参数；而普通的实例方法，通过实例对象调用时，Python将实例对象作为第一个参数传入，静态方法是类中的函数，不需要实例。静态方法主要是用来存放逻辑性的代码，逻辑上属于类，但是和类本身没有关系，也就是说在静态方法中，不会涉及到类中的属性和方法的操作。可以理解为，静态方法是个独立的、单纯的函数，它仅仅托管于某个类的名称空间中，便于使用和维护。	
- `classmethod`方法：当以实例对象或者类对象调用`classmethod`方法时，Python将类对象（如果是实例对象调用，则提取该实例所属的类对象）传入函数的第一个参数`cls`中		

类的实例方法中，用哪个实例调用的该方法，`self`就是指向那个实例对象，类的`classmethod`方法中，用哪个类调用该方法，`cls`就指向那个类对象。类对象与实例对象都是可变对象，可以给类属性、实例属性进行赋值，这就是原地修改。这种行为会影响对它的多处引用。若类的某个属性是可变对象，则对它的修改会立即影响所有的实例对象。多重继承中，超类在`class`语句首行内的顺序很重要。Python搜索继承树时总是根据超类的顺序，从左到右搜索超类。类对象的`.__mro__`属性。它是一个`tuple`，里面存放的是类的实例方法名解析时需要查找的类。Python根据该元组中类的前后顺序进行查找。类对象的`.__mro__`列出了`getattr()`函数以及`super()`函数对实例方法名字解析时的类查找顺序。

`super()`函数：`super()`返回一个`super`实例对象，它用于代理实例方法/类方法的执行：`super(class,an_object)`：要求`isinstance(an_object,class)`为真。代理执行了实例方法调用；`super(class,class2)`：要求 `issubclass(class2,class)`为真。代理执行了类方法调用

有两种特殊用法：`super(class)`：返回一个非绑定的`super`对象，在类的实例方法中，直接调用`super()`，等价于`super(classname,self)`，这里`self`可能是`classname`子类实例，在类的类方法中，直接调用`super()`，等价于`super(classname,cls)`（这里`cls`可能是`classname`子类）

原理：`super`的原理类似于：首先从`mro`中找到对应的`cls`然后从这个开始寻找对应的方法。

``` python
def super(cls,instance):
	mro=instance.__class__.__mro__ #通过 instance生成 mro
	return mro[mro.index(cls)+1] #查找cls在当前mro中的index,返回cls的下一个元素
```

```python
class Root:
	def method1(self):
		print("this is Root")
class B(Root):
	def method1(self):
		super(B,self).method1() #也可以简写为 super().method1()
class C(Root):
	def method1(self):
		super().method1() #也可以写成super(C,self).method1()
class D(B,C):
	pass
```

调用`D().method1()`--> `D`中没有`method1` ；`B`中找到（查找规则：`D.__mro__`)  --> 执行`B`中的`method1`。此时`self`为D实例。`D.__mro__`中，`B`的下一个是`C`，因此`super(B,self）.method1()`从类`C`中查找`method1`；执行`C`的`method1`。此时`self`为D实例。`D.__mro__`中，`C`的下一个是`Root`，因此`super(C,self）.method1()`从类`Root`中查找`method1`；执行`Root`的`method1`；`print(self)`可以看到，这里的`self`全部为 `D`的实例

在面向对象的术语中，通常描述现有的类为基类、父类或者超类，而称新定义的类为子类。有两种方式可以让子类有别于父类。子类可以通过提供一个新的覆盖现有方法的实现方法特化一个现有的行为。子类也可以通过提供一些权限的方法扩展其父类。如一个类的唯一目的是作为继承的基类，那么这个类就是一个抽象基类。更正式地说，一个抽象类不能直接实例化，而具体的类可以被实例化。

封装：将内部实现包裹起来，对外透明，提供`api`接口进行调用的机制。将数据与具体操作的实现代码放在某个对象内部，外部无法访问。必须要先调用类的方法才能启动。
继承：即一个派生类继承父类的变量和方法。
多态：根据对象类型的不同以不同的方式进行处理。

###### 魔法方法

| 魔法方法                         | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `__module__`                     | 前者表示当前操作对象在属于那个模块；                         |
| `__call__(self[, args...])`      | 允许一个类的实例像函数一样被调用：`x(a, b) `调用` x.__call__(a, b)` |
| `__getattr__(self, name)`        | 定义当用户试图获取一个不存在的属性时的行为                   |
| `__setattr__(self, name, value)` | 定义当一个属性被设置时的行为                                 |
| `__getitem__(self, key)`         | 定义获取容器中指定元素的行为，相当于` self[key]`             |
| `__setitem__(self, key, value)`  | 定义设置容器中指定元素的行为，相当于 `self[key] = value`     |
| `__delitem__(self, key)`         | 定义删除容器中指定元素的行为，相当于` del self[key]`         |
| `__contains__(self, item)`       | 定义当使用成员测试运算符`in` 或` not in`时的行为             |
| `__reversed__(self)`             | 定义当被 `reversed() `调用时的行为                           |
| `__bases__`                      | 获取指定类的所有父类构成元素，使用方法为类名`.__bases__`·    |
| `__hash__(self)`                 | 定义当被` hash() `调用时的行为                               |

##### 元类

所有用户定义的类都是`type`类对象的实例，`type`类是应用最广的元类。`class`语句的内部机制：在一条`class`语句的末尾，Python会调用`type`类的构造函数来创建一个`class`对象。

```python
MyClass=type(classname,superclasses,attributedict) #新建了一个类，类名叫MyClass
# classname:类名，会成为MyClass类的 .__name__属性
# superclasses:类的超类元组，会成为MyClass类的 .__bases__属性
# attributedict:类的命名空间字典，会成为MyClass类的 .__dict__ 属性
```

`type`类定义了一个`.__call__(...)`方法。该方法运行`type`类定义的两个其他方法：

* `.__new__(mclass,classname,superclasses,attributedict)`方法，它返回新建的`MyClass`类，`mclass`：为本元类，这里是`type`类，`classname`：为被创建的类的类名，这里是`'MyClass'`，`superclasses`：为被创建的类的超类元组，`attributedict`：为被创建的类的名字空间字典  
* `.__init__(customclass,classname,superclasses,attributedict)`方法，它初始化新建的`MyClass`类，`customclass`：为被创建的类，这里是`MyClass`类，`classname`：为被创建的类的类名，这里是`'MyClass'`，`superclasses`：为被创建的类的超类元组，`attributedict`：为被创建的类的名字空间字典  

所有的类型均由`type`类创建。要通知Python用一个定制的元类来创建类，可以直接声明一个元类来拦截常规的类创建过程。所有元类必须是`type`的子类

```python
class MetaClass(type):
	def __new__(mclass,classname,superclasses,attributedict):		
		return type.__new__(mclass,classname,superclasses,attributedict)
	def __init__(customclass,classname,superclasses,attributedict):
		return type.__init__(customclass,classname,superclasses,attributedict)
class MyClass(metaclass=MetaClass):
	pass
```

继承的超类也列在括号中，但是要在元类之前，也用逗号分隔：`class MyClass(BaseCls1,BaseCls2,metaclass=MetaClass)`。使用元类声明后，在`class`语句底部进行创建`MyClass`类时，改为调用元类`MetaClass`而不是默认的`type`：`MyClass=Meta('MyClass',superclasses,attributedict)`

* 元类`MetaClass`要实现元类协议：重载元类的`.__new__(Meta,classname,superclasses,attributedict)`方法，它返回新建的`MyClass`类；重载元类的`.__init__(customclass,classname,superclasses,attributedict)`方法，
  它初始化新建的`MyClass`类，`type`类的`.__call__(...)`方法将创建和初始化`MyClass`类对象的调用委托给元类``MetaClass`

事实上元类只用于创建类对象，元类并不产生元类自己的实例。因此元类的名字查找规则有些不同：`.__call__`，`.__new__`，`.__init__`方法均在类中查找；元类的继承：元类声明由子类继承，即子类的构建也是由父类的元类负责，如果元类是以函数的方式声明，则子类的构建不再继承这个函数式元类；元类中的属性并不进入自定义类的命名空间，即元类中声明的一些类属性与被创建类的名字空间无关，自定义的类，如果没有显示指定元类，也没有指定父类，则默认使用`type`作为元类

##### 对象引用、可变性和垃圾回收

每个对象至少包含三个数据：引用计数、类型、值。引用计数用于内存管理。类型在`CPython`层使用，用于确保运行时的类型安全性。最后，值，即与对象关联的实际值。`id()`返回对象的内存地址。`is `当且仅当两个对象具有相同的内存地址时才返回True。

###### C中变量

```c
int x=2337	
```

这一行代码在执行时有几个不同的步骤：为整数分配足够的内存；将值分配2337给该内存位置；指示x指向该值； 以简化的内存视图显示，它可能如下所示： 

![](../picture/work/37.png)

另一种思考这个概念的方法是在所有权方面。从某种意义上说，`x`拥有内存位置。首先，`x`恰好是一个可以存储整数的空盒子，可以用来存储整数值。当您给`x`赋值时，您将向`x`拥有的盒子中放入一个值。如果你想引入一个新的变量`y`，

```c
int y=x
```

![](../picture/work/38.png)

###### python中的名称

``` python
x=2337
```

与`C`类似，python在执行过程中分解为几个不同的步骤：创建一个`PyObject`；将`PyObject`的`typecode`设置为整数`PyObject`；将`PyObject`的值设置为2337；创建一个名称`x`；将`x`指向新的`PyObject`；将`PyObject`引用计数增加`1`

![](../picture/work/39.png)

```python
x=2338
```

这行代码：创建一个新的`PyObject`；将`PyObject`的`typecode`设置为整数；将`PyObject`的值设置为2338；将`x`指向新的`PyObject`；将新的`PyObject`引用计数增加1；将旧的`PyObject`引用计数减少1

![](../picture/work/40.png)

```python
y=x
```

![](../picture/work/41.png)

Python在内存中预先创建了某个对象子集，并将它们保存在全局命名空间中以供日常使用。哪些对象依赖于Python的预实现。`CPython 3.7`预实现对象如下：-5到256之间的整数；仅包含ASCII字母，数字或下划线的字符串。这背后的原因是这些变量很可能在许多程序中使用。通过预先实现些对象，Python可以防止对一致使用的对象进行内存分配调用。

当标识符a和b是同一个对象的别名时，表达式`a is b`的结果为真，表达式`a==b`是一个更一般的等价概念。如果标识符a和b指向同一个对象，那么表达式`a==b`为真。如果标识符指向不同的对象，但这些对象的值被认为是等价的，那么`a==b`的结果也为真。精确的等价概念取决于数据类型。

python中的赋值语句不会创建对象的副本，而只是给对象绑定了新的名称。浅拷贝会创建一个新的集合对象，然后用原对象的引用来填充它。实质上，浅拷贝只有一层。拷贝过程不会递归，因此不会创建子对象本身的副本。深拷贝会递归拷贝过程。这意味着会首先构造一个新的集合对象，然后递归地填充原始对象中的子对象的副本。以这种方式拷贝对象会遍历整个对象树，从而创建原始对象及其所有子对象的完全独立的副本。

所有python对象拥有三个属性：身份、类型、值。可变对象值值可变，身份不可变；不可变对象指身份和值都不可变。每个对象都会在内存中申请一块空间来保存该对象，该对象在内存中所在位置的地址被称为引用。在开发程序时，所定义的变量名实际就是对象的地址引用。赋值的本质就是让多个变量同时引用同一个对象的地址。引用实际就是内存中的一个数字地址编号，在使用对象时，只要知道这个对象的地址，就可以操作这个对象，但是因为这个数字地址不方便在开发时使用和记忆，所以使用变量名的形式来代替对象的数字地址。 在 Python 中，变量就是地址的一种表示形式，并不开辟开辟存储空间。

可变对象和不可变对象在拷贝时情况是不一样的：不可变对象的拷贝只在修改的时候才会在内存中开辟新的空间，而拷贝实际上是让多个对象同时指向同一个引用，和对象赋值没有区别。可变对象在浅拷贝时只拷贝第一层中的引用，深拷贝时，会逐层拷贝，直到所有的引用都是不可变对象位置。

![](../picture/1/32.png)

理解 Python 中的赋值语句，应该始终先读右边。对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。因为变量只不过是标注，所以无法阻止为对象贴上多个标注。贴的多个标注，就是别名。每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理解为对象在内存中的地址。Python 唯一支持的参数传递模式是共享传参。共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。这种方案的结果是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识

##### `del`和垃圾回收

`del `语句删除名称，而不是对象。`del `命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。 重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。在 `CPython `中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少引用指向自己。当引用计数归零时，对象立即就被销。`CPython 2.0 `增加了分代垃圾回收算法，用于检测引用循环中涉及的对象组——如果一组对象之间全是相互引用，即使再出色的引用方式也会导致组中的对象不可获取。正是因为有引用，对象才会在内存中存在。当对象的引用数量归零后，垃圾回收程序会把对象销毁。

内存泄漏- 这里的泄漏，并不是说你的内存出现了信息安全问题，被恶意程序利用了，而是指程序本身没有设计好，导致程序未能释放已不再使用的内存。- 内存泄漏也不是指你的内存在物理上消失了，而是意味着代码在分配了某段内存后，因为设计错误，失去了对这段内存的控制，从而造成了内存的浪费。也就是这块内存脱离了gc的控制

当一个对象不再调用的时候，也就是当这个对象的引用计数为 0 的时候，说明这个对象永不可达，自然它也就成为了垃圾，需要被回收。可以简单的理解为没有任何变量再指向它。python针对循环引用，有它的自动垃圾回收算法1. 标记清除算法、2. 分代收集。标记清除的步骤总结为如下步骤1. `GC`会把所有的活动对象打上标记；2. 把那些没有标记的对象非活动对象进行回收/对于一个有向图，如果从一个节点出发进行遍历，并标记其经过的所有节点；那么，在遍历结束后，所有没有被标记的节点，我们就称之为不可达节点。显而易见，这些节点的存在是没有任何意义的，自然的，我们就需要对它们进行垃圾回收。但是每次都遍历全图，对于 Python 而言是一种巨大的性能浪费。所以，在 Python 的垃圾回收实现中，mark-sweep 使用双向链表维护了一个数据结构，并且只考虑容器类的对象。分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。

#### 序列的修改、散列和切片

Python 的序列协议只需要 `__len__ `和 `__getitem__ `两个方法。任何类，只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。

调用`dir(slice)`得到的结果中有个`indices`属性，`S.indices(len) -> (start, stop, stride)`给定长度为` len`的序列，计算 S 表示的扩展切片的起始和结尾索引，以及步幅。超出边界的索引会被截掉，这与常规切片的处理方式一样。换句话说，`indices` 方法开放了内置序列实现的棘手逻辑，用于优雅地处理缺失索引和负数索引，以及长度超过目标序列的切片。这个方法会“整顿”元组，把` start、stop` 和`stride` 都变成非负数，而且都落在指定长度序列的边界内。

`my_seq[a:b:c]` 句法背后的工作原理：创建 `slice(a, b, c)`对象，交给` __getitem__ `方法处理。`a:b:c `这种用法只能作为索引或者下标用在` [] `中来返回一个切片对象：`slice(a, b,c)`。对 `seq[start:stop:step] `进行求值的时候，Python 会调用`seq.__getitem__(slice(start, stop, step))`。要正确处理这种` [] `运算符的话，对象的特殊方法 `__getitem__ `和 `__setitem__ `需要以元组的形式来接收`a[i, j] `中的索引。也就是说，如果要得到 `a[i, j] `的值，Python 会调用`a.__getitem__((i, j))`。

#### 从协议到抽象基类

鸭子类型：对象的类型无关紧要，只要实现了特定的协议即可。猴子补丁：在运行时修改类或模块，而不改动源码。猴子补丁很强大，但是打补丁的代码与要打补丁的程序耦合十分紧密，而且往往要处理隐藏和没有文档的部分。白鹅类型指，只要`cls`是抽象基类，即`cls`的元类是`abc.ABCMeta`，就可以使用`isinstance(obj, cls)`。

![](../picture/1/34.png)

`Iterable、Container `和 `Sized`:各个集合应该继承这三个抽象基类，或者至少实现兼容的协议。`Iterable `通过
`__iter__ `方法支持迭代，`Container`通过 `__contains__ `方法支持`in `运算符，`Sized`通过 `__len__ `方法支持 `len() `函数。`Sequence、Mapping `和 `Set`这三个是主要的不可变集合类型，而且各自都有可变的子类。`Callable `和 `Hashable`这两个抽象基类与集合没有太大的关系，只不过因为` collections.abc `是标准库中定义抽象基类的第一个模块，而它们又太重要了，因此才把它们放到`collections.abc`模块中。我从未见过`Callable`或`Hashable`的子类。这两个抽象基类的主要作用是为内置函数`isinstance`提供支持，以一种安全的方式判断对象能不能调用或散列。

##### 运算符重载

Python中所有可以被重载的方法名称前、后均有两个下划线字符，以便将它与其他类内定义的名字区分开来，如`__add__`；若使用未定义运算符重载方法，则它可能继承自超类。若超类中也没有则说明你的类不支持该运算，强势使用该运算符则抛出异常  

`.__init__(self,args)`方法：称为构造函数。当新的实例对象构造时，会调用`.__init__(self,args)`方法。它用于初始化实例的状态  

`.__getitem__(self,index)`和`.__setitem(self,index,value)__`方法：对于实例对象的索引运算，会自动调用`.__getitem__(self,index)`方法，将实例对象作为第一个参数传递，方括号内的索引值传递给第二个参数;对于分片表达式也调用`.__getitem__(self,index)`方法。实际上分片边界如`[2:4]`绑定到了一个`slice`分片对象上，该对象传递给了`.__getitem__`方法。  对于带有一个`.__getitem__`方法的类，该方法必须既能针对基本索引（一个整数），又能针对分片调用（一个`slice`对象作为参数；`.__getitem__(self,index)`也是Python的重载迭代方式之一。一旦定义了这个方法，`for`循环每一次循环时可以调用`.__getitem__(self,index)`方法。因此任何响应了索引运算的内置或者用户自定义的实例对象通用可以响应迭代。

`.__setitem(self,index,value)__`方法类似地拦截索引赋值和分片赋值。第一个参数为实例对象，第二个参数为基本索引或者分片对象，第三个参数为值  

`.__index__(self)`方法：该方法将实例对象转换为整数值。即当要求整数值的地方出现了实例对象时自行调用。  

`.__getattr__(self,'name')`方法：拦截属性点号运算`obj.name`。只有当对未定义的属性名称进行点号运算时，实例对象会调用此方法，当Python可以从继承树中找到该属性名时，并不会调用`.__getattr__(self,'name')`方法，属性不仅仅是变量名，也可以是方法名，内置的`getattr(obj,'name')`函数等价于调用`obj.name`，它执行继承搜索。搜不到时调用`.__getattr__(self,“name”)`方法，如果没有定义`.__getattr__(self,“name”)`方法，则对于不知道如何处理的属性，则Python抛出内置的`AttributeError`异常  

`.__setattr__(self,'name',value)`方法：拦截所有的属性赋值语句对于属性赋值语句，因为如果该属性曾经不存在，则一旦赋值就增加了一个新的属性，属性不仅仅是变量名，也可以是方法名，注意：`.__setattr__(self,'name',value)`方法的函数体内，任何对`self`属性赋值语句(`self.name=value`)都会再次递归调用`.__setattr__(self,'name',value)`函数，为了防止`.__setattr__(self,'name',value)`函数体内的无穷递归，在该方法内的`self`属性赋值要采用属性字典索引的方法：`self.__dict__['name']=value`，内置的`setattr(obj,'name',value)`函数等价于调用`obj.name=value`

`.__getattribute__(self,'name')`方法：拦截所有的属性读取，而不仅仅是那些未定义的。注意：`.__getattribute__(self,'name')`方法的函数体内，任何对`self`属性读取语句(`self.name`)都会再次递归调用`.__getattribute__(self,'name')`函数。尽量不要重载`.__getattribute__(self,'name')`方法避免无穷递归

通过`.__getattr__`与`.__setattr__`方法混合使用可以模拟实例对象的私有属性：实例对象保存一个`self.private`变量名列表，对`.__setattr__`与`.__getattr__`，判断属性名是否在`self.private`变量名列表中。若是，则抛出异常

`.__call__(self,*pargs,**kwargs)`方法：函数调用方法。当调用实例对象时，由`.__call__(self,*pargs,**kwargs)`方法拦截。`.__call__(self,*pargs,**kwargs)`方法支持所有的参数传递方式 

运算符重载的作用是让用户定义的对象使用中缀运算符如`+`和`|`或一元运算符如`-`和`~`。说得宽泛一些，在 Python 中，函数调用`()`、属性访问`.`和元素访问 / 切片`[]`也是运算符。不能重载内置类型的运算符；不能新建运算符，只能重载现有的；某些运算符不能重载`is、and、or`和`not`

| 类别               | 方法名和对应的运算符                                         |
| ------------------ | ------------------------------------------------------------ |
| 一元运算符         | `__neg__ -、__pos__ +、__abs__ abs()`                        |
| 众多比较运算符     | `__lt__ <、__le__ <=、__eq__ ==、__ne__ !=、__gt__ >、__ge__ >=` |
| 算术运算符         | `__add__ +、__sub__ -、__mul__ *、__truediv__ /、__floordiv__ //、__mod__ %、__divmod__<br/>divmod()、__pow__ ** 或pow()、__round__ round()` |
| 反向算术运算符     | `__radd__、__rsub__、__rmul__、__rtruediv__、__rfloordiv__、__rmod__、__rdivmod__、__rpow__` |
| 增量赋值算术运算符 | `__iadd__、__isub__、__imul__、__itruediv__、__ifloordiv__、__imod__、__ipow__` |
| 位运算符           | `__invert__ ~、__lshift__ <<、__rshift__ >>、__and__ &、__or__` |
| 反向位运算符       | `__rlshift__、__rrshift__、__rand__、__rxor__、__ror__`      |
| 增量赋值位运算符   | `__ilshift__、__irshift__、__iand__、__ixor__、__ior__`      |

跟运算符无关的特殊方法

| 类别                    | 方法名                                                       |
| ----------------------- | ------------------------------------------------------------ |
| 字符串/字节序列表示形式 | `__repr__、__str__、__format__、__bytes__`                   |
| 数值转换                | `__abs__、__bool__、__complex__、__int__、__float__、__hash__、__index__` |
| 集合模拟                | `__len__、__getitem__、__setitem__、__delitem__、__contains__` |
| 迭代枚举                | `__iter__、__reversed__、__next__`                           |
| 可调用模拟              | `__call__`                                                   |
| 上下文管理              | `__enter__、__exit__`                                        |
| 实例创建和销毁          | `__new__、__init__、__del__`                                 |
| 属性管理                | `__getattr__、__getattribute__、__setattr__、__delattr__、__dir__` |
| 属性描述符              | `__get__、__set__、__delete__`                               |
| 跟类相关的服务          | `__prepare__、__instancecheck__、__subclasscheck__`          |

Python 为中缀运算符特殊方法提供了特殊的分派机制。对表达式`a + b`来说，解释器会执行以下几步操作。(1) 如果`a`有`__add__`方法，而且返回值不是 `NotImplemented`，调用`a.__add__(b)`，然后返回结果。(2) 如果`a`没有`__add__ `方法，或者调用`__add__ `方法返回`NotImplemented`，检查`b`有没有 `__radd__ `方法，如果有，而且没有返回`NotImplemented`，调用`b.__radd__(a)`，然后返回结果。(3) 如果`b`没有`__radd__`方法，或者调用`__radd__`方法返回`NotImplemented`，抛出`TypeError`，并在错误消息中指明操作数类型不支持。

![](../picture/1/43.png)

### 控制流程

可迭代对象：在逻辑上它保存了一个序列，在迭代环境中依次返回序列中的一个元素值。迭代协议：`.__next__()`方法。任何对象只要实现了迭代协议，则它就是一个迭代器对象，迭代器对象调用`.__next__()`方法，会得到下一个迭代结果，在一系列迭代之后到达迭代器尾部，若再次调用`.__next__()`方法，则会触发`StopIteration`异常，迭代器在Python中是用C语言的速度运行的，因此速度最快。内置的`iter()`函数用于从序列、字典、`set`以及其他可迭代对象中获取迭代器。对任何迭代器对象`iterator`，调用`iter(iterator)`返回它本身，迭代器对象实现了迭代协议，文件对象本身是一个迭代器对象。即文件对象实现了迭代协议，因此打开多个文件会返回同一个文件对象，列表、元组、字典、`set`、字符串等不适迭代器对象，他们没有实现迭代协议。因此每次调用`iter()`均返回一个新迭代器对象。他们支持安装多个迭代器，每个迭代器状态不同，在原地修改列表、`set`、字典时，会实时反映到它们的迭代器上。`range`对象不支持`.__next__()`，因此它本身不是迭代器，而`map`、`zip`、`filter`对象都是迭代器。字典的视图：键视图、值视图、字典视图都没有`.__next__()`方法，因此他们都不是迭代器  

Python的所有迭代环境都会首先尝试调用`.__iter__(self)`方法，再尝试调用`.__getitem__(self,index)`方法。要让实例对象支持多个迭代器，`.__iter__(self)`方法必须创建并返回新的迭代器对象。

* `.__iter__(self)`方法必须返回一个迭代器对象。Python的迭代环境通过重复调用这个迭代器对象的`.__next__(self)`方法，直到发生了`StopIteration`异常。`.__iter__(self)`返回的迭代器对象会在调用`.__next__(self)`的过程中明确保留状态信息，因此比`.__getitem__(self,index)`方法具有更好的通用性，迭代器对象没有重载索引表达式，因此不支持随机的索引运算。`.__iter__(self)`返回的迭代器只能顺序迭代一次。因此每次要进行新的一轮循环时必须创建一个新的迭代器对象
* 对于调用`.__getitem__(self,index)`的环境，Python的迭代环境通过重复调用该方法，其中`index`每轮迭代中从 0 依次递增，直到发生了`IndexError`异常  

类通常把`in`成员关系运算符实现为一个迭代，用`.__iter__(self)`方法或`.__getitem__(self,index)`方法。也能实现`.__contains__(self,value)`方法来实现特定成员关系。`.__contains__(self,value)`方法优先于`.__iter__(self)`方法，`.__iter__(self)`方法优先于`.__getitem__(self,index)`方法采纳  

#### 可迭代对象、迭代器和生成器

迭代是数据处理的基石。扫描内存中放不下的数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项。这就是迭代器模式。所有生成器都是迭代器，因为生成器完全实现了迭代器接口。迭代器用于从集合中取出元素；而生成器用于“凭空”生成元素。在Python中，所有集合都可以迭代。

可迭代的对象使用`iter`内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的`__iter__ `方法，那么对象就是可迭代的。序列都可以迭代；实现了 `__getitem__ `方法，而且其参数是从零开始的索引，这种对象也可以迭代。标准的迭代器接口有两个方法。`__next__`返回下一个可用的元素，如果没有元素了，抛`StopIteration`异常。`__iter__`返回`self`，以便在应该使用可迭代对象的地方使用迭代器

![](../picture/1/38.png)

只要Python函数的定义体中有`yield`关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。生成器函数会创建一个生成器对象，包装生成器函数的定义体。把生成器传给`next(...) `函数时，生成器函数会向前，执行函数定义体中的下一个`yield`语句，返回产出的值，并在函数定义体的当前位置暂停。最终，函数的定义体返回时，外层的生成器对象会抛出`StopIteration`异常——这一点与迭代器协议一致。

##### 标准库中的生成器函数

###### 用于过滤的生成器函数

| 函数                                      | 说明                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| `itertools.compress(it, selector_it)`     | 并行处理两个可迭代的对象；如果`selector_it`中的元素是真值，产出`it`中对应的元素 |
| `itertools.dropwhile(predicate, it)`      | 处理`it`，跳过`predicate`的计算结果为真值的元素，然后产出剩下的各个元素 |
| `itertools.filterfalse(predicate, it)`    | 与`filter`函数的作用类似，不过`predicate`的逻辑是相反的：`predicate`返回假值时产出对应的元素 |
| `itertools.islice(it, start, stop, step)` | 产出`it`的切片，作用类似于`s[start:stop:step]`，不过`it`可以是任何可迭代的对象，而且这个函数实现的是惰性操作 |
| `itertools.takewhile(predicte, it)`       | `predicate`返回真值时产出对应的元素，然后立即停止，不再继续检查。 |

###### 用于映射的生成器函数

| 函数                              | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `itertools.accumulate(it[,func])` | 产出累积的总和；如果提供了`fun`，那么把前两个元素传给它，然后把计算结果和下一个元素传给它，以此类推，最后产出结果 |
| `enumerate(iterable, start = 0)`  | 产出由两个元素组成的元组，结构是`(index, item)`，其中`index`从`start`开始计数，`item`则从`iterable`中获取 |
| `map(func, it1[, it2, ..., itN])` | 把`it`中的各个元素传给`func`，产出结果；如果传入`N`个可迭代的对象，那么`func`必须能接受`N`个参数，而且要并行处理各个可迭代的对象 |
| `itertools.starmap(func, it)`     | 把`it`中的各个元素传给`func`，产出结果；输入的可迭代对象应该产出可迭代的元素`iit`，然后以`func(*iit)`这种形式调用`func` |

###### 合并多个可迭代对象的生成器函数

| 函数                                                   | 说明                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| `itertools.chain(it1, ..., itN)`                       | 先产出`it1`中的所有元素，然后产出`it2`中的所有元素，以此类推，无缝连接在一起 |
| `itertools.chain.from_iterable(it)`                    | 产出`it`生成的各个可迭代对象中的元素，一个接一个，无缝连接在一起；`it`应该产出可迭代的元素。 |
| `itertools.product(it1, ..., itN, repeat =1)`          | 计算笛卡儿积：从输入的各个可迭代对象中获取元素，合并成由 `N`个元素组成的元组，与嵌套的`for`循环效果一样；`repeat`指明重复处理多少次输入的可迭代对象 |
| `zip(it1, ..., itN)`                                   | 并行从输入的各个可迭代对象中获取元素，产出由`N`个元素组成的元组，只要有一个可迭代的对象到头了，就默默地停止 |
| `itertools.zip_longest(it1, ..., itN, fillvalue=None)` | 并行从输入的各个可迭代对象中获取元素，产出由`N`个元素组成的元组，等到最长的可迭代对象到头后才停止，空缺的值使用`fillvalue`填充 |

###### 把输入的各个元素扩展成多个输出元素的生成器函数

| 函数                                                   | 说明                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| `itertools.combination(it, out_len)`                   | 把`it`产出的`out_len`个元素组合在一起，然后产出              |
| `itertools.combinations_with_replacement(it, out_len)` | 把`it`产出的`out_len`个元素组合在一起，然后产出，包含相同元素的组合 |
| `itertools.count(start=0, step=1)`                     | 从`start`开始不断产出数字，按`step`指定的步幅增加            |
| `itertools.cycle(it)`                                  | 从`it`中产出各个元素，存储各个元素的副本，然后按顺序重复不断地产出各个元素 |
| `itertools.permutation(it, out_len=None)`              | 把`out_len`个`it`产出的元素排列在一起，然后产出这些排列；`out_len`的默认值等于`len(list(it))` |
| `itertools.repeat(item[, times])`                      | 重复不断地产出指定的元素，除非提`times`，指定次数            |

###### 用于重新排列元素的生成器函数

| 函数                                    | 说明                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| `itertools.groupby(iter, key = None)`   | 产出由两个元素组成的元素，形式为`(key, group)`，其中`key`是分组标准，`group`是生成器，用于产出分组里的元素 |
| `itertools.tee(it, n =2)`               | 产出一个由`n`个生成器组成的元组，每个生成器用于单独产出输入的可迭代对象中的元素 |
| `functools.reduce(func, it[, initial])` | 把前两个元素传给`func`，然后把计算结果和第三个元素传给 `func`，以此类推，返回最后的结果；如果提供了`initial`，把它当作第一个元素传入 |

`iter`函数还有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调用的对象创建迭代器。这样使用时，第一个参数必须是可调用的对象，用于不断调，产出各个值；第二个值是哨符，这是个标记值，当可调用的对象返回这个值时，触发迭代器抛出`StopIteration`异常，而不产出哨符。

#### 上下文管理和`else`块

`for/else、while/else `和 `try/else `的语义关系紧密，不过与`if/else`差别很大。`for`仅当 `for `循环运行完毕时才运行`else`块。`while`仅当`while`循环因为条件为假值而退出时才运行`else`块。`try`仅当`try `块中没有异常抛出时才运行`else`块。在所有情况下，如果异常或者`return、break`或`continue`语句导致控制权跳到了复合
语句的主块之外，`else`子句也会被跳过。

上下文管理器对象存在的目的是管理`with`语句，就像迭代器的存在是为了管理`for`语句一样。`with`语句的目的是简化`try/finally `模式。这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、`return `语句或 `sys.exit() `调用而中止，也会执行指定的操作。`finally `句中的代码通常用于释放重要的资源，或者还原临时变更的状态。上下文管理器协议包含 `__enter__ `和 `__exit__ `两个方法。`with `语句开始运行时，会在上下文管理器对象上调用 `__enter__ `方法。`with `语句运行结束后，会在上下文管理器对象上调用 `__exit__ `方法，以此扮演`finally`子句的角色。执行`with`后面的表达式得到的结果是上下文管理器对象，不过，把值绑定到目标变量上是在上下文管理器对象上调用` __enter__ `方法的结果。

```
with expression [as var]:
	statements
```

`expression`必须返回一个对象，该对象必须支持环境管理协议。其工作方式为：计算`expression`表达式的值，得到环境管理器对象。环境管理器对象必须有`.__enter__(self)`方法和`.__exit__(self, exc_type, exc_value, traceback)`方法；调用环境管理器对象的`.__enter__(self)`方法。如果有`as`子句，`.__enter__(self)`方法返回值赋值给`as`子句中的变量`var`；如果没有`as`子句，则`.__enter__(self)`方法返回值直接丢弃；执行`statements`代码块；如果`statements`代码块抛出异常，则`.__exit__(self, exc_type, exc_value, traceback)`方法自动被调用；若`.__exit__()`方法返回值为`False`，则重新抛出异常到`with`语句之外；若`.__exit__()`方法返回值为`True`，则异常终止于此，并不会抛出`with`语句之外；如果`statements`代码块未抛出异常，则`.__exit__(self, exc_type, exc_value, traceback)`方法自动被调用，调用参数为：`.__exit__(self,None,None,None)`。`with`语句可以指定多个环境管理器，以逗号分隔。根据定义的顺序这些环境管理器对象的`.__enter__(self)`方法顺序调用，`.__exit__(self, exc_type, exc_value, traceback)`方法逆序调用

`@contextmanager `装饰器能减少创建上下文管理器的样板代码量，因为不用编写一个完整的类，定义 `__enter__ `和 `__exit__ `方法，而只需实现有一个`yield`语句的生成器，生成想让 `__enter__ `方法返回的值。
在使用` @contextmanager `装饰的生成器中，`yield `语句的作用是把函数的定义体分成两部分：`yield `语句前面的所有代码在`with`块开始时即解释器调用 `__enter__ `方法时执行， `yield`语句后面的代码在`with`块结束时即调用 `__exit__ `方法时执行。其实，`contextlib.contextmanager `装饰器会把函数包装成实现 `__enter__ `和
`__exit__ `方法的类。这个类的 `__enter__ `方法有如下作用。调用生成器函数，保存生成器对象。调用 `next(gen)`，执行到`yield`关键字所在的位置。返回`next(gen)`产出的值，以便把产出的值绑定到`with/as`语句中的目标变量上。with 块终止时，`__exit__ `方法会做以下几件事。检查有没有把异常传给`exc_type`；如果有，调用`gen.throw(exception)`，在生成器函数定义体中包含`yield`关键字的那一行抛出异常。否则，调用 `next(gen)`，继续执行生成器函数定义体中`yield`语句之后的代码`。

### 元编程

管理属性的工具：`.__getattr__(self,name)`方法：拦截所有未定义属性的读取（它要么返回一个值，要么抛出`AttributeError`异常；`.__setattr__(self,name,value)`方法：拦截所有属性的读取赋值；`.__getattribute__(self,name)`方法：拦截所有属性的读取；`property`特性：将特定属性访问定位到`get`方法和`set`方法；描述符协议：将特定属性访问定位到具有任意`get`和`set`方法的实例对象。描述符：描述符是作为独立的类创建，它的实例是赋值给了类属性，描述符的实例可以由子类继承，描述符的实例管理一个单一的特定的属性，从技术上讲，`property()`创建的是一个描述符实例，描述符实例针对想要拦截的属性名访问操作，它提供了特定的方法。描述符类的接口为（即描述符协议）：

```python
class Descriptor:
	def __get__(self,instance,owner):
		pass
	def __set__(self,instance,value):
		pass
	def __delete__(self,instance):
		pass
class A:
	attr=Descriptor()
	...
```

* `instance`参数为：`None`：当用于类的属性访问时；类`A`的实例对象：当用于实例的属性访问时
* `owner`参数为：使用该描述符的类`A`
* 当访问类实例或者类属性时，自动调用该类的描述符实例的方法。如果该类的描述符中某些方法空缺则：若` __set__(self,instance,value)`未定义，则写该属性抛出`AttributeError`，该属性只读；若` __get__(self,instance,owner)`未定义，则读该属性返回一个`Descriptor`实例，因为从继承树中可知，该属性返回由类的`attr`变量名指定的对象
* 状态信息可以保持在实例对象中，也可以保存在描述符实例中。因为在这3个方法中，`self`,`instance`都可以访问

`.__delattr__(self,name)`方法拦截属性的删除

由于`.__getattribute__(self,name)`方法和`.__setattr__(self,name,value)`方法对所有的属性拦截，因此他们的实现特别要小心，注意不要触发无穷递归。

* `.__getattribute__(self,name)`方法中，若要取属性则可以用超类的`.__getattribute__(self,name)`获取。如果通过`.__dict__`方法获取则会再次触发`.__getattribute__(self,name)`的调用，因为`__dict__`本身就是对象的属性。
* `.__setattr__(self,name,value)`方法中，若要设置属性可以用`self.__dict__[name]=value`的方法，或者用超类的`.__setattr__(self,name,value)`方法
* 所有使用内置操作隐式的获取方法名属性，`.__getattr__(self,name)`、`.__setattr__(self,name,value)`、
  `.__getattribute__(self,name)`方法都不会拦截，因为Python在类中查找这样的属性，完全忽略了在实例中查找

属性拦截优先级：在读取属性方面，`__getattribute__`优先级最高；在写属性方面，`__setattr__`优先级最高；在删除属性方面，`__del__`优先级最高；如果没有`__getattribute__`，`__setattr__`与`__del__`，则读写删属性取决于描述符（`property`也是一种特殊的描述符）。其中如果同一个属性指定了多个描述符，则后面的描述符覆盖前面的描述符；`__getattribute__`与`__getattr__`区别：`__getattribute__`在任何属性读取的时候拦截，而`__getattr__`只有在未定义属性读取的时候拦截（约定俗成地，它要么返回一个值，要么返回`AttributeError`）。其中若二者同时存在则`__getattribute__`优先级较高

描述符的作用是用来代理一个类的属性，需要注意的是描述符不能定义在被使用类的构造函数中，只能定义为类的属性，它只属于类的，不属于实例。类的`__dict__`属性是类的一个内置属性，类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类`__dict__`里。在输出描述符的变量时，会调用描述符中的`__get__`方法，在设置描述符变量时，会调用描述符中的`__set__`方法。

 描述符分为数据描述符和非数据描述符。至少实现了内置`__set__()`和`__get__()`方法的描述符称为数据描述符；实现了除`__set__()`()以外的方法的描述符称为非数据描述符。描述符的优先级的高低顺序：类属性 > 数据描述符 > 实例属性 > 非数据描述符 > 找不到的属性触发`__getattr__()`。

函数在使用@property 装饰器装饰后，会变成类属性，而且会有一个 setter 方法，该方法也是一个装饰器，作用是装饰同属性(特性)的 set 函数。被装饰的函数必须与属性（被@property 装饰器装饰的函数）同名。当类函数被 @property 装饰时，实际上，这个函数已经成为了该类的特性，也就是该类的类属性了，这个过程在解释器导入该模块时就已经确定了。

#### 动态属性和特性

在 Python 中，数据的属性和处理数据的方法统称属性attribute。其实，方法只是可调用的属性。除了这二者之外，我们还可以创建特性property，在不改变类接口的前提下，使用存取方法即读值方法和设值方法修改数据属性仅当无法使用常规的方式获取属性即在实例、类或超类中找不到指定的属性，解释器才会调用特殊的 `__getattr__ `方法。`__new__`方法构造实例，返回`self`作为其他方法的实例使用。

```python
from collections import abc
class FrozenJSON:
    def __new__(cls, arg):
        if isintance(arg, abc.Mapping):
            return super().__new__(cls)
        elif isinstance(arg, abc.MutableSequence):
            return [cls(item) for item in arg]
        else: return arg
    def __init__(self, mapping):
        self._data = dict(mapping)
    def __getattr__(self, name):
        if hasattr(self._data, name):
            return getattr(self._data, name)
        else:
            return FrozenJSON(self._data[name])
```

`rozenJSON`类只有两个方法`__init__ `和 `__getattr__`和一个实例属性`__data`。因此，尝试获取其他属性会触发解释器调用`__getattr__`方法。我们通常把`__init__`称为构造方法。其实，用于构建实例的是特殊方法`__new__`：这是个类方法使用特殊方式处理，因此不必使用`@classmethod`装饰器，必须返回一个实例。返回的实例会作为第一个参数即self传给`__init__`方法。因为调用`__init__`方法时要传入实例，而且禁止返回任何值，所以`__init__`方法其实是“初始化方法”。真的构造方法是`__new__`。我们几乎不需要自己编写`__new__`方法，因为从`object`类继承的实现已经足够了。刚才说明的过程，即从`__new__`方法到`__init__`方法，是最常见的，但不是唯一的。`__new__`方法也可以**返回其他类的实例**，此时，解释器不会调用 `__init__ `

##### 使用动态属性转换数据类型

##### 特性全解析

`property(fget=None, fset=None, fdel=None, doc=None)`所有参数都是可选的，如果没有把函数传给某个参数，那么得到的特性对象就不允许执行相应的操作。特性都是类属性，但是特性管理的其实是实例属性的存取。实例属性不会遮盖类特性。新添的类特性遮盖现有的实例属性。`obj.attr`这样的表达式不会从`obj`开始寻找`attr`，而是从`obj.__class__`开始，而且，仅当类中没有名为`attr`的特性时，Python才会在`obj`实例中寻找。这条规则不仅适用于特性，还适用于一整类描述符——覆盖型描述符。

##### 处理属性的重要属性和函数

`vars([object])`返回`object`对象的`__dict__ `属性；如果实例所属的类定义了`__slots__`属性，实例没有`__dict__`属性，那么`vars`函数不能处理那个实例。如果没有指定参数，那么`vars()`函数的作用与`locals()`函数一样：返回表示本地作用域的字典。

##### 属性描述符

![](../picture/1/44.png)

描述符类：实现描述符协议的类。托管类：把描述符实例声明为类属性的类。描述符实例：描述符类的各个实例，声明为托管类的类属性。各个描述符实例使用箭头和带下划线的名称表示。与黑色菱形接触的`LineItem`类包含描述符实例。托管实例：托管类的实例。储存属性：托管实例中存储自身托管属性的属性。`LineItem`实例的`weight`和`price`属性是储存属性。这种属性与描述符属性不同，描述符属性都是类属性。托管属性：托管类中由描述符实例处理的公开属性，值存储在储存属性中。也就是说，描述符实例和储存属性为托管属性建立了基础。

实现`__set__ `方法的描述符属于覆盖型描述符，因为虽然描述符是类属性，但是实现
`__set__ `方法的话，会覆盖对实例属性的赋值操作。特性也是覆盖型描述符：如果没提供设值函数，`property`类中的`__set__`方法会抛出`AttributeError`异常，指明那个属性是只读的。通常，覆盖型描述符既会实现`__set__`方法，也会实现`__get__`方法，不过也可以只实现`__set__`方法。此时，只有写操作由描述符处理。通过实例读取描述符会返回描述符对象本身，因为没有处理读操作的`__get__`方法。如果直接通过实例的`__dict__`属性创建同名实例属性，以后再设置那个属性时，仍会由`__set__`方法插手接管，但是读取那个属性的话，就会直接从实例中返回新赋予的值，而不会返回描述符对象。也就是说，实例属性会遮盖描述符，不过只有读操作是如此。没有实现`__set__`方法的描述符是非覆盖型描述符。如果设置了同名的实例属性，描述符会被遮盖，致使描述符无法处理那个实例的那个属性。不管描述符是不是覆盖型，为类属性赋值都能覆盖描述符。这是一种猴子补丁技术，这其实会导致依赖描述符的类不能正确地
执行操作。

###### 方法是描述符

在类中定义的函数属于绑定方法，因为用户定义的函数都有`__get__`方法，所以依附到类上时，就相当于描述符。函数没有实现`__set__`方法，因此是非覆盖型描述符。与描述符一样，通过托管类访问时，函数的`__get__`方法会返回自身的引用。但是，通过实例访问时，函数的`__get__`方法返回的是绑定方法对象：一种可调用的对象，里面包装着函数，并把托管实例绑定给函数的第一个参数。绑定方法对象还有个`__call__`方法，用于处理真正的调用过程。这个方法会调用`__func__`属性引用的原始函数，把函数的第一个参数设为绑定方法的`__self__`属性。这就是形参 self 的隐式绑定方式。函数会变成绑定方法，这是 Python 语言底层使用描述符的最好例证。

**使用特性以保持简单**内置的`property`类创建的其实是覆盖型描述符，`__set__`方法和 `__get__ `方法都实现了，即便不定义设值方法也是如此。特性的`__set__`方法默认抛出`AttributeError: can't set attribute`，因此创建只读属性最简单的方式是使用特性。**只读描述符**必须有`__set__`方法如果使用描述符类实现只读属性，要记住，`__get__ `和`__set__`两个方法必须都定义，否则，实例的同名属性会遮盖描述符。只读属性的`__set__`方法只需抛出`AttributeError`异常，并提供合适的错误消息。**用于验证的描述符**可以只有`__set__`方法对仅用于验证的描述符来说，`__set__`方法应该检查`value`参数获得的值，如果有效，使用描述符实例的名称为键，直接在实例的`__dict__`属性中设置。这样，从实例中读取同名属性的速度很快，因为不用经过`__get__`方法处理。仅有`__get__`方法的描述符可以实现高效缓存如果只编写了`__get__`方法，那么创建的是非覆盖型描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例的`__dict__`属性中获取值，而不会再触发描述符的`__get__`方法。
**非特殊的方法可以被实例属性遮盖**由于函数和方法只实现了`__get__`方法，它们不会处理同名实例属性的赋值操作。因此，像`my_obj.the_method = 7`这样简单赋值之后，后续通过该实例访问`the_method`得到的是数字 7——但是不影响类或其他实例。然而，特殊方法不受这个问题的影响。解释器只会在类中寻找特殊的方法，也就是说，`repr(x)`执行的其实是`x.__class__.__repr__(x)`，因此`x`的`__repr__`属性对`repr(x)`方法调用没有影响。出于同样的原因，实例的`__getattr__`属性不会破坏常规的属性访问规则。