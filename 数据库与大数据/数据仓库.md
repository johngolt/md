

#### 维度数据模型

##### 事实表

事实表一般由数字值和指向维度表的外键组成。事实表中一条记录所表达的业务细节程度被称为粒度。

### 数据仓库实施步骤

![](../picture/2/307.png)

![](../picture/2/308.png)

实施一个数据仓库项目的主要步骤是：定义项目范围、收集并确认业务需求和技术需求、逻辑设计、物理设计、从源系统向数据仓库装载数据、使数据可以被访问以 辅助决策、管理和维护数据仓库。

#### 确定技术需求

###### 数据转化

数据格式的标准化，如日期；码值的统一；空值的预处理，空值设置默认值；重复数据的处理，同一条数据出现多次；字段内容标准化，如去除空格、回车符；数据类型的统一；指标的预计算，如产品单价*购买数量＝金额；数据合并，合并多个数据源的数据并去重；数据质量验证，实现设定规则验证数据质量，并根据验证成功进行后续转载处理，验证失败的需要确定是直接丢弃还是记录下来进一步处理。

常见的数据质量问题可以根据数据源的多少和所属层次分为 4 类。

1. 单数据源定义层：违背字段约束条件（例如日期出现 9 月 31 日），字段属性依赖冲突（例如描述同一个人的同一属性的两条记录，值不同），违反唯一性（同一个主键出现了多次）等。
2. 单数据源实例层：单个属性值含有过多信息，拼写错误，存在空白值，存在噪音数据，数据重复，数据过时等；
3. 多数据源定义层：同一个实体的不同称呼（如`custom_id`、`custom_num`），同一种属性的不同定义（例如，字段长度定义不一致，字段类型不一致等）；
4. 多数据源实例层：数据的维度、粒度不一致（如有的按照年度统计，有的按照月份统计），数据重复，拼写错误等。

噪声数据是指数据中存在着错误或异常的数据，不完整数据是指感兴趣的属性没有值，而不一致数据则是指数据内涵出现不一致情况。

###### 数据装载

 这个步骤实际上涉及整个`ETL`过程。需要执行的任务包括：源和目标结构之间建立映射关系；从源系统抽取数据；对数据进行清洗和转换；将数据装载进数据仓库； 创建并存储元数据。 

`ETL`过程分成了抽取和转换装载两个部分。抽取过程负责从操作型系统获取数据，该过程一般不做数据聚合和汇总，但是会按照主题进行集成，物理上是将操 作型系统的数据全量或增量复制到数据仓库系统的`ODS`中。转换装载过程并将数据进行清洗、过滤、汇总、统一格式化等一系列转换操作，使数据转为适合查询的格式， 然后装载进数据仓库系统的`DW`中。

`ETL`的最后步骤是把转换后的数据装载进目标数据仓库。这步操作需要重点考虑两个问题，一是数据装载的效率问题，二是一旦装载过程中途失败了，如何再次重复执行装载过程。

要提高装载的效率，加快装载速度，可以从以下几方面入手。首先保证足够的系统资源。在进行数据装载时，要禁用数据库约束（唯一性、非空性，检查约束等）和索引，当装载过程完全结束后，再启用这些约束，重建索引。

#### 逻辑设计

 建立需要的数据列表：一般从主题域涉及的业务因素入手。例如，销售主题域的业务因素可能是客户、地区、产品、促销等。然后建立每个业务因素的元素列表，依据也是用户提出的需求。最后通过元素列表，标识出业务因素之间的联系。这些工作完成后，应该已经获得了如下的信息：原始的或计算后的数据元素列表；数据的属性，比如是字符型的还是数字型的；合理的数据分组，比如国 家、省市、区县等分成一组，因为它们都是地区元素；数据之间的关系，比如国家、省市、区县的包含关系等。 

识别数据源：现在已经有了需要的数据列表，下面的问题是从哪里可以得到这些数据，以及要得到这些数据需要多大的成本。需要把上一步建立的数据列表映射到操作型系统上。 应该从最大最复杂的源系统开始，在必要时再查找其他源系统。数据的映射关系可能是直接的或间接的。通常维度模型中的维度表可以直接映射到操作型源系统，而事实表的度量则映射到源数据在特定粒度级别上聚合计算后的结果。

制作实体关系图：逻辑设计的交付物是`ERD`实体关系图和对它的说明文档（数据字典）。实体对应关系数据库中的表，属性对应关系数据库中的列。在维度模型的`ERD`中，实体由事实表和维度表组成，关系体现为在事实表中引用维度表的主键。因此先要确认哪些信息属于中心事实表，哪些信息属于相关的维度表。

#### 物理设计

位图索引对索引列的每个不同值建立一个位图。和普通的B树索引相比，位图索引占用的空间小，创建速度快。但由于并发的`DML`操作会锁定整个位图段的大量数据行，所以位图索引不适用于频繁更新的事务处理系统。而数据仓库对最终用户来说是一个只读系统，其中某些维度的值基数很小，这样的场景非常适合利用位图索引优化查询。

 大部分数据库系统都可以对表进行分区。表分区是将一个大表按照一定的规则分解成多个分区，每个表分区可以定义独立的物理存储参数。将不同分区存储到不同的磁盘上，查询表中数据时可以有效分布I/O操作，缓解系统压力。分区还有一个很有用的特性，叫做分区消除。查询数据的时候，数据库系统的优化器可以通过适当的查询条件过滤掉一些分区，从而避免扫描所有数据，提高查询效率，这就是分区消除。

物理设计指的是将逻辑设计的对象集合，转化为一个物理数据库，包括所有的表、索引、约束、视图等。物理数据库结构需要优化以获得最佳的性能。每种数据库产品都有自己特别的优化方法，这些优化对查询性能有极大的影响。比较通用的数据仓库优化方法有位图索引和表分区。 除了性能优化，数据仓库系统的可扩展性也非常重要。简单地说，可扩展性就是能够处理更大规模业务的特性。

在数据库物理设计上简要说明在设计分析型系统数据库时应该考虑的一些问题。 

- 表分区。可以独立定义表分区的物理存储属性，将不同分区的数据存放到多个物理文件上，这样做一方面可以分散I/O；另一方面，当数据量非常大时，方便数据 维护；再有就是利用分区消除查询数据时，不用扫描整张表，从而提高查询性能。
- 位图索引。当查询条件中包含低基数（不同值很少，例如性别）的列，尤其是包含有这些列上的or、and或not这样的逻辑运算时，或者从有大量行的表中返回大量 的行时，应考虑位图索引。 
- 物化视图。物化视图物理存储查询所定义的数据，能够自动增量刷新数据，并且可以利用查询重写特性极大地提高查询速度，是分析型系统常用的技术。
- 并行化操作。可以在查询大量数据时执行并行化操作，这样会导致多个服务器进程为同一个查询语句工作，使用该查询可以快速完成，但是会耗费更多的资源。

统一数仓建模是业务层建模的基础，需要涵盖尽可能多的业务过程和维度，包括业务建模、数据建模和物理建模三个阶段。


业务建模的目的是为了对业务需求进行分解，转化为数据理解，
包括的具体流程有：划分业务域、确认业务过程、设计事件事实，确认相关实体、关联事件、构建业务总线矩阵。

业务域划分，业务域是业务过程的集合，是对业务各个环节的粗粒度划分，将相关的业务过程聚集到一个业务域下，例如播放域。

确认业务过程：业务过程是业务中的原子行为，不能再进行拆解，我们需要在业务建模过程中，确认有哪些业务过程，并明确业务过程所属的业务域，一个业务过程只能属于一个业务域。

设计事件事实。

确认相关实体：从较粗的粒度确认一个业务过程涉及到的实体范围，为关联事件实体提供联接节点。

关联事件事实：统一数仓建模需要将已有的事件事实字段都涵盖到，并通过实体进行更多维度的关联。

构建业务总线矩阵：横纵坐标分别为描述事实本身的业务域、业务过程，以及描述事实环境的维度和实体。

数据建模阶段主要是为了将业务总线矩阵进行细化，完成业务关系到数据关系逻辑转换，并补充相关的维度，输出星型（雪花）模型。

确认业务：一般不跨业务，针对单个业务进行建模。

确认业务过程：可以面向单个或者多个业务过程。

确认维度：业务过程中包含的维度。

确认度量：业务过程中涉及到的度量。

退化维度属性：一些通用的维度属性退化到明细层模型，尽量减少与维表之间的join操作。

构建星型模型：指导后续开发操作。

物理建模实际上是对数据模型的物化过程，物化过程会根据不同引擎在流程上有细微差别，最终将数据模型物化成Hive的物理表/视图，甚至是带有Schema结构的Kafka Topic，下面以Hive物理表为例描述整个过程。

确认数据模型：选择需要物化的数据模型。

确认表名：根据数仓规范补充完善表名信息，例如计算周期、表类型、业务信息等。

确认描述/使用说明：补充对表信息的中文描述以及使用注意事项。

确认分区字段：例如天级、小时级。

确认生命周期：根据数据重要性，设置数据保留的时间范围，例如30天、1年等。

生成物理表：同时将表的业务元数据信息录入到元数据中心，与模型完全对应，表名、字段名、字段类型等信息标准化、统一化。

如之前所述，统一数仓作为底层模型和数据的基础来源，业务集市/主题数仓基于已有的底层模型进行建模，主要包括数据建模，
物理建模（当然，可以通过统一数仓业务建模阶段输出的业务总线矩阵更加了解业务）。

业务层数据建模的目标是输出主题的数据星型模型，根据不同的主题和分析场景，选取相关的业务过程，
使用合理的建模手段进行数据建模，主要流程包括：确认主题、选取业务过程、确认粒度、确认维度、确认统计指标，
最终输出星型模型。

确认主题：根据具体的分析需求确认主题。

选取业务过程：确认需要分析的业务以及业务过程。

确认统一数仓模型：系统自动推荐相关的模型，选择满足条件的模型，并在此基础上进行后续建模工作。

确认粒度：相同粒度模型可以进行指标的合并。

确认维度：选取后续需要下钻分析的维度，选取过程是在业务过程的范围内进行，不能超出维度能够关联的范围。

确认统计指标：选取业务过程相关的度量（原子指标元数据）派生的统计指标。

构建星型模型。

逻辑主键（surrogate key）：无意义的字段，即自增长字段，即identity。这其中还有一个选择GUID(Globally Unique Identifier)。  也叫代理主键。
业务主键（natrual key）：有意义的字段，比如身份证 ID。也叫自然主键

##### 拉链表

| 列名         | 类型        | 说明                                   |
| ------------ | ----------- | -------------------------------------- |
| goods_id     | varchar(50) | 商品编号                               |
| goods_status | varchar(50) | 商品状态（待审核、待售、在售、已删除） |
| createtime   | varchar(50) | 商品创建日期                           |
| modifytime   | varchar(50) | 商品修改日期                           |

`2019年12月20日`的数据如下所示：

| **goods_id** | **goods_status** | **createtime** | **modifytime** |
| :----------: | :--------------: | :------------: | :------------: |
|     001      |      待审核      |   2019-12-20   |   2019-12-20   |
|     002      |       待售       |   2019-12-20   |   2019-12-20   |
|     003      |       在售       |   2019-12-20   |   2019-12-20   |
|     004      |      已删除      |   2019-12-20   |   2019-12-20   |

###### 快照

每一天都保存一份全量，将所有数据同步到数仓中

`2019年12月20日`中数仓的数据如下所示

| **goods_id** | **goods_status** | **createtime** | **modifytime** |
| :----------: | :--------------: | :------------: | :------------: |
|     001      |      待审核      |   2019-12-18   |   2019-12-20   |
|     002      |       待售       |   2019-12-19   |   2019-12-20   |
|     003      |       在售       |   2019-12-20   |   2019-12-20   |
|     004      |      已删除      |   2019-12-15   |   2019-12-20   |

`2019年12月21日`中数仓的数据如下所示

|      **goods_id**      |    **goods_status**    | **createtime** | **modifytime** |
| :--------------------: | :--------------------: | :------------: | :------------: |
| 以下为12月20日快照数据 |                        |                |                |
|          001           |         待审核         |   2019-12-18   |   2019-12-20   |
|          002           |          待售          |   2019-12-19   |   2019-12-20   |
|          003           |          在售          |   2019-12-20   |   2019-12-20   |
|          004           |         已删除         |   2019-12-15   |   2019-12-20   |
| 以下为12月21日快照数据 |                        |                |                |
|          001           | 待售（从待审核到待售） |   2019-12-18   |   2019-12-21   |
|          002           |          待售          |   2019-12-19   |   2019-12-20   |
|          003           |          在售          |   2019-12-20   |   2019-12-20   |
|          004           |         已删除         |   2019-12-15   |   2019-12-20   |
|     005（新商品）      |         待审核         |   2019-12-21   |   2019-12-21   |
|     006（新商品）      |         待审核         |   2019-12-21   |   2019-12-21   |

在MySQL中`zw`库和`商品表`用于到`原始数据层`

```mysql
-- 创建数据库
create database if not exists zw;
-- 创建商品表
create table if not exists `zw`.`t_product`(
goods_id varchar(50), -- 商品编号
 goods_status varchar(50), -- 商品状态
 createtime varchar(50), -- 商品创建时间
 modifytime varchar(50) -- 商品修改时间
);
```

在MySQL中创建ods和dw层 `模拟数仓`

```mysql
-- ods创建商品表
create table if not exists `zw`.`ods_t_product`(
goods_id varchar(50), -- 商品编号
 goods_status varchar(50), -- 商品状态
 createtime varchar(50), -- 商品创建时间
 modifytime varchar(50), -- 商品修改时间
cdat varchar(10)   --模拟hive分区
)default character set = 'utf8'; ;
-- dw创建商品表
create table if not exists `zw`.`dw_t_product`(
goods_id varchar(50), -- 商品编号
 goods_status varchar(50), -- 商品状态
 createtime varchar(50), -- 商品创建时间
 modifytime varchar(50), -- 商品修改时间
 cdat varchar(10)  -- 模拟hive分区
)default character set = 'utf8'; ;
```

```mysql
# 从原始数据层导入到ods 层
insert into zw.ods_t_product
select *,'20191220' from zw.t_product ;
# 从ods同步到dw层
insert into zw.dw_t_product
select * from zw.ods_t_product where cdat='20191220';
```

导入12月21数据

```mysql
# 从原始数据层导入到ods 层
insert into zw.ods_t_product
select *,'20191221' from zw.t_product ;
# 从ods同步到dw层
insert into zw.dw_t_product
select * from zw.ods_t_product where cdat='20191221';
```

表`每天`保留一份`全量`，每次全量中会保存`很多不变的信息`，如果数据量很大的话，对存储是极大的浪费     

###### 拉链表

- 拉链表不存储冗余的数据，只有某`行的数据发生变化，才需要保存下来`，相比每次全量同步会节省存储空间
- 能够查询到历史快照
- 额外的增加了两列（`dw_start_date`、`dw_end_date`），为数据行的生命周期

12月20日商品拉链表的数据

| **goods_id** | **goods_status** | **createtime** | **modifytime** | **dw_start_date** | **dw_end_date** |
| :----------: | :--------------: | :------------: | :------------: | :---------------: | :-------------: |
|     001      |      待审核      |   2019-12-18   |   2019-12-20   |    2019-12-20     |   9999-12-31    |
|     002      |       待售       |   2019-12-19   |   2019-12-20   |    2019-12-20     |   9999-12-31    |
|     003      |       在售       |   2019-12-20   |   2019-12-20   |    2019-12-20     |   9999-12-31    |
|     004      |      已删除      |   2019-12-15   |   2019-12-20   |    2019-12-20     |   9999-12-31    |

12月21日商品拉链表的数据

| **goods_id** | **goods_status** | **createtime** | **modifytime** | **dw_start_date** | **dw_end_date** |
| :----------: | :--------------: | :------------: | :------------: | :---------------: | :-------------: |
|     001      |      待审核      |   2019-12-18   |   2019-12-20   |    2019-12-20     |   2019-12-21    |
|     002      |       待售       |   2019-12-19   |   2019-12-20   |    2019-12-20     |   9999-12-31    |
|     003      |       在售       |   2019-12-20   |   2019-12-20   |    2019-12-20     |   9999-12-31    |
|     004      |      已删除      |   2019-12-15   |   2019-12-20   |    2019-12-20     |   9999-12-31    |
|  001（变）   |       待售       |   2019-12-18   |   2019-12-21   |    2019-12-21     |   9999-12-31    |
|  005（新）   |      待审核      |   2019-12-21   |   2019-12-21   |    2019-12-21     |   9999-12-31    |

```mysql
-- ods创建商品表
create table if not exists `zw`.`ods_t_product2`(
goods_id varchar(50), -- 商品编号
 goods_status varchar(50), -- 商品状态
 createtime varchar(50), -- 商品创建时间
 modifytime varchar(50), -- 商品修改时间
cdat varchar(10)   -- 模拟hive分区
)default character set = 'utf8';
-- dw创建商品表
create table if not exists `zw`.`dw_t_product2`(
goods_id varchar(50), -- 商品编号
 goods_status varchar(50), -- 商品状态
 createtime varchar(50), -- 商品创建时间
 modifytime varchar(50), -- 商品修改时间
 dw_start_date varchar(12), --  生效日期
 dw_end_date varchar(12), -- 失效时间
 cdat varchar(10)  -- 模拟hive分区
)default character set = 'utf8'; 
```

将数据导入到数仓中的ods层

```mysql
insert into zw.ods_t_product2
select *,'20191220' from zw.t_product_2 where modifytime >='2019-12-20'
```

将数据从ods层导入到dw层

```mysql
insert into zw.dw_t_product2
select goods_id, goods_status, createtime, modifytime, modifytime,'9999-12-31', cdat from zw.ods_t_product2 where cdat='20191220'
```

增量导入2019年12月21日数据，原始数据层同步到ods层

```mysql
insert into zw.ods_t_product2
select *,'20191221' from zw.t_product_2 where modifytime >='2019-12-21';
```

编写ods层到dw层重新计算 dw_end_date

```mysql
select t1.goods_id, t1.goods_status, t1.createtime, t1.modifytime,
       t1.dw_start_date,
       case when (t2.goods_id is not null and t1.dw_end_date>'2019-12-21') then '2019-12-21'else t1.dw_end_date end as end ,
       t1.cdat
from zw.dw_t_product2 t1
left join (select * from zw.ods_t_product2 where cdat='20191221')t2 on t1.goods_id=t2.goods_id
union
select goods_id, goods_status, createtime, modifytime, modifytime,'9999-12-31', cdat from zw.ods_t_product2 where cdat='20191221'
```

